"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const helper_1 = require("./helper.js");
const client_1 = require("../lib/client.js");
const n3_1 = require("n3");
const types_1 = require("@treecg/types");
const fs_1 = require("fs");
const oldFetch = global.fetch;
(0, globals_1.beforeEach)(() => {
    (0, fs_1.rmSync)("save.json", {
        force: true,
    });
    if ("mockClear" in global.fetch) {
        console.log("Clearing");
        global.fetch.mockClear();
    }
    console.log("running test.");
    global.fetch = oldFetch;
});
(0, globals_1.afterEach)(() => {
    if ("mockClear" in global.fetch) {
        console.log("Clearing");
        global.fetch.mockClear();
    }
    console.log("done with test.");
    global.fetch = oldFetch;
});
(0, globals_1.describe)("Simple Tree", () => {
    function simpleTree(perPage = 1, pages = 2, values = [3, 2], delay) {
        // root -> first -> second
        const tree = new helper_1.Tree((x, numb) => new n3_1.Parser().parse(`<${x}> <http://example.com/value> ${numb}.`), "http://example.com/value");
        let prev = tree.root();
        for (let j = 0; j < pages; j++) {
            const first = tree.newFragment(delay);
            for (let i = 0; i < perPage; i++) {
                tree.fragment(first).addMember("a" + j + i, values[j * perPage + i]);
            }
            tree.fragment(prev).relation(first, "https://w3id.org/tree#relation");
            prev = first;
        }
        return tree;
    }
    (0, globals_1.test)("ascending tree, emits ordered", async () => {
        const tree = simpleTree(1);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "ascending");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(2);
        (0, globals_1.expect)(members.map((x) => x.timestamp)).toEqual(["2", "3"].map((x) => new Date(x)));
    });
    (0, globals_1.test)("descending tree, emits ordered", async () => {
        const tree = simpleTree(1);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "descending");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(2);
        (0, globals_1.expect)(members.map((x) => x.timestamp)).toEqual(["3", "2"].map((x) => new Date(x)));
    });
    (0, globals_1.test)("tree handles backpressure", async () => {
        const tree = simpleTree(2, 6, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 50);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "none");
        const stream = client.stream({ highWaterMark: 1, size: () => 1 });
        await new Promise((res) => setTimeout(res, 500));
        (0, globals_1.expect)(tree.fetched.length).toEqual(5);
        const members = await (0, helper_1.read)(stream);
        (0, globals_1.expect)(members.length).toBe(12);
    });
    (0, globals_1.test)("unordered tree, emits", async () => {
        const tree = simpleTree();
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "none");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(2);
        (0, globals_1.expect)(members.map((x) => x.timestamp)).toEqual(["3", "2"].map((x) => new Date(x)));
    });
});
(0, globals_1.describe)("more complex tree", () => {
    function simpleTree() {
        // root (2) -GTE> first (3)
        //  |> second (2)
        const tree = new helper_1.Tree((x, numb) => new n3_1.Parser().parse(`<${x}> <http://example.com/value> ${numb}.`), "http://example.com/value");
        tree.fragment(tree.root()).addMember("a", 5);
        const first = tree.newFragment();
        tree.fragment(first).addMember("b", 3);
        tree
            .fragment(tree.root())
            .relation(first, types_1.TREE.GreaterThanOrEqualToRelation, "http://example.com/value", "3");
        const second = tree.newFragment();
        tree.fragment(second).addMember("c", 2);
        tree.fragment(tree.root()).relation(second, types_1.TREE.relation);
        return tree;
    }
    (0, globals_1.test)("tree handles backpressure", async () => {
        const tree = simpleTree();
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "none");
        const stream = client.stream({ highWaterMark: 1, size: () => 1 });
        await new Promise((res) => setTimeout(res, 500));
        console.log(tree.fetched);
        (0, globals_1.expect)(tree.fetched.length).toEqual(5);
        const members = await (0, helper_1.read)(stream);
        (0, globals_1.expect)(members.length).toBe(3);
    });
    (0, globals_1.test)("unordered tree, emits", async () => {
        const tree = simpleTree();
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "none");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(3);
    });
    (0, globals_1.test)("ascending tree, emits ordered", async () => {
        const tree = simpleTree();
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "ascending");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(3);
        (0, globals_1.expect)(members.map((x) => x.timestamp)).toEqual(["2", "3", "5"].map((x) => new Date(x)));
    });
    (0, globals_1.test)("descending tree, emits ordered", async () => {
        const tree = simpleTree();
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "descending");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(3);
        (0, globals_1.expect)(members.map((x) => x.timestamp)).toEqual(["5", "3", "2"].map((x) => new Date(x)));
    });
    (0, globals_1.test)("ordered tree, emits asap", async () => {
        const tree = simpleTree();
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
        }, "ascending");
        const first = await client.stream().getReader().read();
        (0, globals_1.expect)(first.done).toBe(false);
        (0, globals_1.expect)(first.value?.timestamp).toEqual(new Date("2"));
    });
    (0, globals_1.test)("Polling works, single page", async () => {
        // return;
        const tree = new helper_1.Tree((x, numb) => new n3_1.Parser().parse(`<${x}> <http://example.com/value> ${numb}.`), "http://example.com/value");
        tree.fragment(tree.root()).addMember("a", 5);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            polling: true,
            url: base,
        }, "none");
        let hasPolled = undefined;
        const polled = new Promise((res) => (hasPolled = res));
        let added = false;
        client.on("poll", () => {
            console.log("Poll cycle!");
            if (!added) {
                tree.fragment(tree.root()).addMember("b", 7);
                added = true;
                hasPolled({});
            }
        });
        const reader = client.stream().getReader();
        const first = await reader.read();
        (0, globals_1.expect)(first.done).toBe(false);
        (0, globals_1.expect)(first.value?.timestamp).toEqual(new Date("5"));
        await polled;
        const second = await reader.read();
        (0, globals_1.expect)(second.done).toBe(false);
        (0, globals_1.expect)(second.value?.timestamp).toEqual(new Date("7"));
        await reader.cancel();
    });
    (0, globals_1.test)("Polling works, single page - ordered", async () => {
        const tree = new helper_1.Tree((x, numb) => new n3_1.Parser().parse(`<${x}> <http://example.com/value> ${numb}.`), "http://example.com/value");
        tree.fragment(tree.root()).addMember("a", 5);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            polling: true,
            url: base,
        }, "ascending");
        let hasPolled = undefined;
        const polled = new Promise((res) => (hasPolled = res));
        let added = false;
        client.on("poll", () => {
            console.log("Poll cycle!");
            if (!added) {
                tree.fragment(tree.root()).addMember("b", 7);
                added = true;
                hasPolled({});
            }
        });
        const reader = client.stream().getReader();
        const first = await reader.read();
        (0, globals_1.expect)(first.done).toBe(false);
        (0, globals_1.expect)(first.value?.timestamp).toEqual(new Date("5"));
        console.log("Awaiting promise");
        await polled;
        console.log("Promise resolved");
        const second = await reader.read();
        (0, globals_1.expect)(second.done).toBe(false);
        (0, globals_1.expect)(second.value?.timestamp).toEqual(new Date("7"));
        await reader.cancel();
    });
    (0, globals_1.test)("Exponential backoff works", async () => {
        const tree = new helper_1.Tree((x, numb) => new n3_1.Parser().parse(`<${x}> <http://example.com/value> ${numb}.`), "http://example.com/value");
        tree.fragment(tree.root()).addMember("a", 5);
        const frag = tree.newFragment();
        tree.fragment(tree.root()).relation(frag, "https://w3id.org/tree#relation");
        tree.fragment(frag).setFailcount(2).addMember("b", 7);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
            fetch: (0, client_1.retry_fetch)(fetch, {
                codes: [408, 425, 429, 500, 502, 503, 504],
                base: 100,
                maxRetries: 5,
            }),
        }, "none");
        const members = await (0, helper_1.read)(client.stream());
        (0, globals_1.expect)(members.length).toBe(2);
    });
    (0, globals_1.test)("Exponential backoff works, handle max retries", async () => {
        const tree = new helper_1.Tree((x, numb) => new n3_1.Parser().parse(`<${x}> <http://example.com/value> ${numb}.`), "http://example.com/value");
        tree.fragment(tree.root()).addMember("a", 5);
        const frag = tree.newFragment();
        tree.fragment(tree.root()).relation(frag, "https://w3id.org/tree#relation");
        tree.fragment(frag).setFailcount(5).addMember("b", 7);
        const base = tree.base() + tree.root();
        const mock = tree.mock();
        global.fetch = mock;
        const client = (0, client_1.replicateLDES)({
            url: base,
            fetch: (0, client_1.retry_fetch)(fetch, {
                codes: [408, 425, 429, 500, 502, 503, 504],
                base: 100,
                maxRetries: 5,
            }),
        }, "none");
        let errorCb = false;
        let thrown = false;
        client.on("error", () => (errorCb = true));
        try {
            await (0, helper_1.read)(client.stream());
        }
        catch (ex) {
            thrown = true;
        }
        (0, globals_1.expect)(thrown).toBeTruthy();
        (0, globals_1.expect)(errorCb).toBeTruthy();
    });
});
