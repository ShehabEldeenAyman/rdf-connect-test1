"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const relation_1 = require("../lib/relation.js");
const heap_js_1 = require("heap-js");
(0, globals_1.describe)("Chain relations", () => {
    (0, globals_1.test)("correct chaining", () => {
        let chain = new relation_1.RelationChain("", "");
        chain = chain.push("", { value: 0, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        chain = chain.push("", { value: 0, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: false, value: 0 });
        chain = chain.push("", { value: 1, important: true });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 1 });
        chain = chain.push("", { value: 2, important: true });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 1 });
        chain = chain.push("", { value: 2, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(2);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 1 });
        (0, globals_1.expect)(chain.relations[1]).toEqual({ important: false, value: 2 });
        chain = chain.push("", { value: 2, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(2);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 1 });
        (0, globals_1.expect)(chain.relations[1]).toEqual({ important: false, value: 2 });
        chain = chain.push("", { value: 2, important: true });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
    });
    (0, globals_1.test)("correct chaining with ord", () => {
        let chain = new relation_1.RelationChain("", "", [], undefined, (a, b) => a < b ? -1 : 1);
        chain = chain.push("", { value: 0, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        chain = chain.push("", { value: 0, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: false, value: 0 });
        chain = chain.push("", { value: 1, important: true });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 1 });
        chain = chain.push("", { value: 2, important: true });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 2 });
        chain = chain.push("", { value: 2, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(2);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 2 });
        (0, globals_1.expect)(chain.relations[1]).toEqual({ important: false, value: 2 });
        chain = chain.push("", { value: 2, important: false });
        (0, globals_1.expect)(chain.relations.length).toBe(2);
        (0, globals_1.expect)(chain.relations[0]).toEqual({ important: true, value: 2 });
        (0, globals_1.expect)(chain.relations[1]).toEqual({ important: false, value: 2 });
        chain = chain.push("", { value: 2, important: true });
        (0, globals_1.expect)(chain.relations.length).toBe(1);
    });
    (0, globals_1.test)("correct ordering", () => {
        let value1 = new relation_1.RelationChain("", "").push("", {
            value: 0,
            important: false,
        });
        let value2 = new relation_1.RelationChain("", "").push("", {
            value: 0,
            important: true,
        });
        // unimportant should be handled first!
        (0, globals_1.expect)(value1.ordering(value2)).toBe(-1);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(1);
        value1 = new relation_1.RelationChain("", "").push("", { value: 0, important: false });
        value2 = new relation_1.RelationChain("", "")
            .push("", { value: 0, important: true })
            .push("", {
            value: 1,
            important: false,
        });
        // unimportant should be handled first!
        (0, globals_1.expect)(value1.ordering(value2)).toBe(-1);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(1);
        value1 = new relation_1.RelationChain("", "").push("", { value: 0, important: false });
        value2 = new relation_1.RelationChain("", "")
            .push("", { value: 0, important: false })
            .push("", {
            value: 1,
            important: false,
        });
        // both are not important so they are not ordered
        (0, globals_1.expect)(value1.ordering(value2)).toBe(0);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(0);
        value1 = new relation_1.RelationChain("", "").push("", { value: 0, important: true });
        value2 = new relation_1.RelationChain("", "").push("", { value: 10, important: true });
        // both are imporant, smallest value first
        (0, globals_1.expect)(value1.ordering(value2)).toBe(-1);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(1);
        value1 = new relation_1.RelationChain("", "")
            .push("", { value: 0, important: true })
            .push("", {
            value: 0,
            important: false,
        });
        value2 = new relation_1.RelationChain("", "").push("", { value: 0, important: true });
        (0, globals_1.expect)(value1.ordering(value2)).toBe(0);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(0);
    });
    (0, globals_1.test)("correct ordering with ord", () => {
        const params = [[], undefined, (a, b) => (a == b ? 0 : a < b ? 1 : -1)];
        let value1 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 0,
            important: false,
        });
        let value2 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 0,
            important: true,
        });
        // unimportant should be handled first!
        (0, globals_1.expect)(value1.ordering(value2)).toBe(-1);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(1);
        value1 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 0,
            important: false,
        });
        value2 = new relation_1.RelationChain("", "", ...params)
            .push("", { value: 0, important: true })
            .push("", {
            value: 1,
            important: false,
        });
        // unimportant should be handled first!
        (0, globals_1.expect)(value1.ordering(value2)).toBe(-1);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(1);
        value1 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 0,
            important: false,
        });
        value2 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 1,
            important: false,
        });
        // both are not important so they are not ordered
        (0, globals_1.expect)(value1.ordering(value2)).toBe(0);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(0);
        value1 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 0,
            important: true,
        });
        value2 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 10,
            important: true,
        });
        // both are imporant, smallest value first
        (0, globals_1.expect)(value1.ordering(value2)).toBe(1);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(-1);
        value1 = new relation_1.RelationChain("", "", ...params)
            .push("", { value: 0, important: true })
            .push("", {
            value: 0,
            important: false,
        });
        value2 = new relation_1.RelationChain("", "", ...params).push("", {
            value: 0,
            important: true,
        });
        (0, globals_1.expect)(value1.ordering(value2)).toBe(0);
        (0, globals_1.expect)(value2.ordering(value1)).toBe(0);
    });
    (0, globals_1.test)("heap works with relation", () => {
        const params = [[], undefined, (a, b) => (a == b ? 0 : a < b ? 1 : -1)];
        let value1 = new relation_1.RelationChain("", "", ...params);
        let value2 = new relation_1.RelationChain("", "", ...params).push("", {
            value: new Date("2001-03-01T00:00:00.000Z"),
            important: true,
        });
        const heap = new heap_js_1.default((a, b) => a.ordering(b));
        heap.add(value2);
        heap.add(value1);
        // heap.add(value1);
        (0, globals_1.expect)(heap.length).toBe(2);
        (0, globals_1.expect)(heap.toArray()).toEqual([value1, value2]);
        let eq_value1 = new relation_1.RelationChain("", "", ...params);
        console.log("Removed", heap.remove(eq_value1, (a, b) => a.ordering(b) === 0));
        (0, globals_1.expect)(heap.length).toBe(1);
        (0, globals_1.expect)(heap.toArray()).toEqual([value2]);
    });
    (0, globals_1.test)("heap works with relation (important)", () => {
        const params = [[], undefined, (a, b) => (a == b ? 0 : a < b ? 1 : -1)];
        let value0 = new relation_1.RelationChain("", "", ...params).push("", {
            value: new Date("2001-03-01T00:00:00.000Z"),
            important: true,
        });
        let value1 = new relation_1.RelationChain("", "", ...params).push("", {
            value: new Date("2001-03-01T00:01:00.000Z"),
            important: true,
        });
        let value2 = new relation_1.RelationChain("", "", ...params).push("", {
            value: new Date("2001-03-01T00:02:00.000Z"),
            important: true,
        });
        const heap = new heap_js_1.default((a, b) => a.ordering(b));
        heap.add(value1);
        heap.add(value2);
        heap.add(value0);
        // heap.add(value1);
        console.log(heap.toArray().map(({ relations }) => relations));
        // expect(heap.length).toBe(3);
        (0, globals_1.expect)(heap.toArray()).toEqual([value2, value1, value0]);
    });
});
