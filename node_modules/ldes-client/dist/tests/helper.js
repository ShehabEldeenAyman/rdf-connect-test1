"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tree = exports.Fragment = exports.read = void 0;
const n3_1 = require("n3");
const types_1 = require("@treecg/types");
const BASE = "http://myTree.com/";
function relationToQuads(rel) {
    const path = rel.path ? ` tree:path <${rel.path}>;` : "";
    const value = rel.value ? ` tree:value "${rel.value}";` : "";
    const string = `
@prefix tree: <https://w3id.org/tree#>.

<> tree:relation [
  a <${rel.type}>;
  tree:node <${rel.node}>;
  ${path}
  ${value}
].
`;
    return new n3_1.Parser().parse(string);
}
async function read(stream) {
    return new Promise(async (res, rej) => {
        try {
            const out = [];
            const reader = stream.getReader();
            let el = await reader.read();
            while (el) {
                if (el.done || !el.value)
                    break;
                out.push(el.value);
                el = await reader.read();
            }
            res(out);
        }
        catch (ex) {
            console.log("expect", ex);
            rej(ex);
        }
    });
}
exports.read = read;
class Fragment {
    members = [];
    relations = [];
    failCount = 0;
    delay;
    constructor(delay) {
        this.delay = delay;
    }
    toQuads(ldesId, memberToQuads) {
        if (this.failCount > 0) {
            this.failCount -= 1;
            throw "I'm failing, oh no";
        }
        const out = [];
        for (let rel of this.relations) {
            out.push(...relationToQuads(rel));
        }
        for (let { id, member } of this.members) {
            out.push(...new n3_1.Parser().parse(`<${ldesId}> <${types_1.TREE.member}> <${id}>.`));
            out.push(...memberToQuads(id, member));
        }
        return out;
    }
    setFailcount(count) {
        this.failCount = count;
        return this;
    }
    addMember(id, member) {
        this.members.push({ member, id });
        return this;
    }
    relation(target, type, path, value) {
        this.relations.push({
            type,
            value,
            path,
            node: BASE + target,
        });
    }
}
exports.Fragment = Fragment;
class Tree {
    fragments = [];
    memberToQuads;
    timestampPath;
    fetched = [];
    constructor(memberToQuads, timestampPath) {
        this.timestampPath = timestampPath;
        this.memberToQuads = memberToQuads;
        this.fragments.push(new Fragment());
    }
    base() {
        return BASE;
    }
    root() {
        return 0;
    }
    newFragment(delay) {
        this.fragments.push(new Fragment(delay));
        return this.fragments.length - 1;
    }
    fragment(id) {
        return this.fragments[id];
    }
    mock() {
        const fetch_f = async (req, _opts) => {
            if (!req.toString().startsWith(BASE)) {
                return new Response("", { status: 404 });
            }
            this.fetched.push(req.toString().slice(BASE.length));
            const quads = [];
            if (req.toString() === BASE + this.root()) {
                const path = this.timestampPath
                    ? ` <https://w3id.org/ldes#timestampPath> <${this.timestampPath}>;`
                    : "";
                quads.push(...new n3_1.Parser().parse(`
<> ${path}
  <https://w3id.org/tree#view> <>.
`));
            }
            const index = parseInt(req.toString().substring(BASE.length));
            const fragment = this.fragments[index];
            if (fragment.delay) {
                await new Promise((res) => setTimeout(res, fragment.delay));
            }
            try {
                quads.push(...fragment.toQuads(BASE + this.root(), this.memberToQuads));
                const respText = new n3_1.Writer().quadsToString(quads);
                const resp = new Response(respText, {
                    headers: { "content-type": "text/turtle" },
                });
                return resp;
            }
            catch (ex) {
                const resp = new Response("I'm too loaded yo", { status: 429 });
                return resp;
            }
        };
        return fetch_f;
    }
}
exports.Tree = Tree;
