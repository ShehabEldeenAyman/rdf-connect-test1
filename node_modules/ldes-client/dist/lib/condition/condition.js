import { NamedNode, Parser } from "n3";
import { extractShapes } from "rdf-lens";
import { RdfStore } from "rdf-stores";
import { TREE } from "@treecg/types";
import { SHAPES } from "./shapes.js";
import { cbdEquals } from "./range.js";
export function empty_condition() {
    return new EmptyCondition();
}
export function parse_condition(source, baseIRI) {
    const shapeQuads = new Parser().parse(SHAPES);
    const output = extractShapes(shapeQuads, {
        "https://w3id.org/tree#And": (obj) => new AndCondition(obj),
        "https://w3id.org/tree#Or": (obj) => new OrCondition(obj),
        "https://w3id.org/tree#Condition": (obj) => new LeafCondition(obj),
    });
    const dataQuads = new Parser({ baseIRI: baseIRI }).parse(source);
    return output.lenses["https://w3id.org/rdf-lens/ontology#TypedExtract"].execute({
        quads: dataQuads,
        id: new NamedNode(baseIRI),
    });
}
export class Range {
    min;
    eqMin = true;
    max;
    eqMax = true;
    constructor(value, type) {
        switch (type) {
            case TREE.EqualToRelation:
                this.min = value;
                this.max = value;
                return;
            case TREE.LessThanRelation:
                this.max = value;
                this.eqMax = false;
                return;
            case TREE.LessThanOrEqualToRelation:
                this.max = value;
                return;
            case TREE.GreaterThanRelation:
                this.min = value;
                this.eqMin = false;
                return;
            case TREE.GreaterThanOrEqualToRelation:
                this.min = value;
                return;
        }
    }
    add(value, type) {
        switch (type) {
            case TREE.EqualToRelation:
                this.min = value;
                this.max = value;
                return;
            case TREE.LessThanRelation:
                if (!this.max || value < this.max) {
                    this.max = value;
                    this.eqMax = false;
                }
                return;
            case TREE.LessThanOrEqualToRelation:
                if (!this.max || value < this.max) {
                    this.max = value;
                }
                return;
            case TREE.GreaterThanRelation:
                if (!this.min || value > this.min) {
                    this.min = value;
                    this.eqMin = false;
                }
                return;
            case TREE.GreaterThanOrEqualToRelation:
                if (!this.min || value > this.min) {
                    this.min = value;
                }
                return;
        }
    }
    static empty() {
        return new Range(null, TREE.Relation);
    }
    contains(value) {
        if (this.min) {
            if (this.eqMin) {
                if (this.min > value)
                    return false;
            }
            else {
                if (this.min >= value)
                    return false;
            }
        }
        if (this.max) {
            if (this.eqMax) {
                if (this.max < value)
                    return false;
            }
            else {
                if (this.max <= value)
                    return false;
            }
        }
        return true;
    }
    overlaps(other) {
        if (this.min && other.max) {
            if (this.eqMin && other.eqMax) {
                if (this.min > other.max)
                    return false;
            }
            else {
                if (this.min >= other.max)
                    return false;
            }
        }
        if (this.max && other.min) {
            if (this.eqMax && other.eqMin) {
                if (other.min > this.max)
                    return false;
            }
            else {
                if (other.min >= this.max)
                    return false;
            }
        }
        return true;
    }
    toString(valueToString) {
        const vts = valueToString || ((x) => x.toString());
        const comma = !!this.min && !!this.max ? "," : "";
        const start = this.min ? (this.eqMin ? "[" : "(") + vts(this.min) : "]";
        const end = this.max ? vts(this.max) + (this.eqMax ? "]" : ")") : "[";
        return start + comma + end;
    }
}
export class LeafCondition {
    relationType;
    value;
    compareType;
    path;
    pathQuads;
    range;
    constructor(inp) {
        this.relationType = inp.relationType;
        this.value = inp.value;
        this.compareType = inp.compareType || "string";
        this.path = inp.path;
        const store = RdfStore.createDefault();
        inp.pathQuads.quads.forEach((x) => store.addQuad(x));
        this.pathQuads = { id: inp.pathQuads.entry, store };
        this.range = new Range(this.parseValue(inp.value), inp.relationType.value);
    }
    toString() {
        const vts = this.compareType === "date" ? (x) => x.toISOString() : undefined;
        return `${this.pathQuads.id.value} âˆˆ ${this.range.toString(vts)}`;
    }
    parseValue(value) {
        switch (this.compareType) {
            case "string":
                return value;
            case "date":
                return new Date(value);
            case "integer":
                return parseInt(value);
            case "float":
                return parseFloat(value);
            default:
                return value;
        }
    }
    matchRelation(range, cbdId, verbose) {
        if (!cbdEquals(this.pathQuads, cbdId)) {
            return true;
        }
        if (!range)
            console.log("Rangee is here also undefined, returning false");
        if (!range)
            return false;
        if (verbose) {
            const vts = this.compareType === "date" ? (x) => x.toISOString() : undefined;
            console.log(this.range.toString(vts), "contains", range.toString(vts), this.range.overlaps(range));
        }
        return this.range.overlaps(range);
    }
    matchMember(member) {
        const value = this.parseValue(this.path.execute(member)[0].id.value);
        return this.range.contains(value);
    }
}
class BiCondition {
    alpha;
    beta;
    constructor(inp) {
        this.alpha = inp.alpha;
        this.beta = inp.beta;
    }
    matchRelation(range, cbdId, verbose) {
        const alpha = this.alpha.matchRelation(range, cbdId, verbose);
        const beta = this.beta.matchRelation(range, cbdId, verbose);
        if (verbose) {
            console.log(">", this.combine(alpha, beta));
        }
        return this.combine(alpha, beta);
    }
    matchMember(member) {
        const alpha = this.alpha.matchMember(member);
        const beta = this.beta.matchMember(member);
        return this.combine(alpha, beta);
    }
}
export class AndCondition extends BiCondition {
    combine(alpha, beta) {
        return alpha && beta; // TODO those might be null if something cannot make a statement about it, important for not condition
    }
    toString() {
        return `(${this.alpha.toString()} ^ ${this.beta.toString()})`;
    }
}
export class OrCondition extends BiCondition {
    combine(alpha, beta) {
        return alpha || beta; // TODO those might be null if something cannot make a statement about it, important for not condition
    }
    toString() {
        return `(${this.alpha.toString()} V ${this.beta.toString()})`;
    }
}
export class EmptyCondition {
    matchRelation(_range, _cbdId, verbose) {
        if (verbose)
            console.log("Returning true");
        return true;
    }
    matchMember(_member) {
        return true;
    }
    toString() {
        return "all";
    }
}
