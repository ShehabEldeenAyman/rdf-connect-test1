import { Quad, Term } from "@rdfjs/types";
import { BasicLensM, Cont } from "rdf-lens";
import { Member } from "../page.js";
import { Path } from "./range.js";
type RdfThing = {
    entry: Term;
    quads: Quad[];
};
export interface Condition {
    matchRelation(range: Range | undefined, cbdId: Path, verbose?: boolean): boolean;
    matchMember(member: Member): boolean;
    toString(): string;
}
export declare function empty_condition(): Condition;
export declare function parse_condition(source: string, baseIRI: string): Condition;
type CompareTypes = "string" | "date" | "integer" | "float";
export declare class Range {
    min?: any;
    eqMin: boolean;
    max?: any;
    eqMax: boolean;
    constructor(value: any, type: string);
    add(value: any, type: string): void;
    static empty(): Range;
    contains(value: any): boolean;
    overlaps(other: Range): boolean;
    toString(valueToString?: (value: any) => string): string;
}
export declare class LeafCondition implements Condition {
    relationType: Term;
    value: string;
    compareType: CompareTypes;
    path: BasicLensM<Cont, Cont>;
    pathQuads: Path;
    range: Range;
    constructor(inp: {
        relationType: Term;
        value: string;
        compareType?: string;
        path: BasicLensM<Cont, Cont>;
        pathQuads: RdfThing;
    });
    toString(): string;
    private parseValue;
    matchRelation(range: Range | undefined, cbdId: Path, verbose?: boolean): boolean;
    matchMember(member: Member): boolean;
}
declare abstract class BiCondition implements Condition {
    alpha: Condition;
    beta: Condition;
    constructor(inp: {
        alpha: Condition;
        beta: Condition;
    });
    abstract combine(alpha: boolean, beta: boolean): boolean;
    matchRelation(range: Range | undefined, cbdId: Path, verbose?: boolean): boolean;
    matchMember(member: Member): boolean;
}
export declare class AndCondition extends BiCondition {
    combine(alpha: boolean, beta: boolean): boolean;
    toString(): string;
}
export declare class OrCondition extends BiCondition {
    combine(alpha: boolean, beta: boolean): boolean;
    toString(): string;
}
export declare class EmptyCondition implements Condition {
    matchRelation(_range: Range, _cbdId: Path, verbose?: boolean): boolean;
    matchMember(_member: Member): boolean;
    toString(): string;
}
export {};
