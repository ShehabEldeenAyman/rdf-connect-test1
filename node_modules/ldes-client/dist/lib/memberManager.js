import { TREE } from "@treecg/types";
import debug from "debug";
import { getObjects, memberFromQuads } from "./utils.js";
const log = debug("manager");
export class Manager {
    queued = 0;
    closed = false;
    resolve;
    ldesId;
    state;
    extractor;
    shapeId;
    timestampPath;
    isVersionOfPath;
    constructor(ldesId, state, info) {
        const logger = log.extend("constructor");
        this.ldesId = ldesId;
        this.state = state;
        this.extractor = info.extractor;
        this.timestampPath = info.timestampPath;
        this.isVersionOfPath = info.isVersionOfPath;
        this.shapeId = info.shape;
        logger("new %s %o", ldesId.value, info);
    }
    // Extract members found in this page, this does not yet emit the members
    extractMembers(page, state, notifier) {
        const logger = log.extend("extract");
        const members = getObjects(page.data, this.ldesId, TREE.terms.member, null);
        logger("%d members", members.length);
        const promises = [];
        for (let member of members) {
            if (!this.state.has(member.value)) {
                const promise = this.extractMember(member, page.data)
                    .then((member) => {
                    if (member) {
                        if (!this.closed) {
                            notifier.extracted(member, state);
                        }
                    }
                    return member;
                })
                    .catch((ex) => {
                    logger("Error %o", ex);
                    notifier.error({ error: ex, type: "extract", memberId: member }, state);
                    var err = new Error();
                    console.log(err.stack);
                });
                promises.push(promise);
            }
        }
        Promise.all(promises).then((members) => {
            logger("All members extracted");
            if (!this.closed) {
                notifier.done(members.flatMap((x) => (x ? [x] : [])), state);
            }
        });
    }
    close() {
        log("Closing");
        if (this.resolve) {
            this.resolve();
            this.resolve = undefined;
        }
        this.closed = true;
        log("this.resolve()");
    }
    length() {
        return this.state.size;
    }
    async extractMemberQuads(member, data) {
        return await this.extractor.extract(data, member, this.shapeId);
    }
    async extractMember(member, data) {
        if (this.state.has(member.value))
            return;
        const quads = await this.extractMemberQuads(member, data);
        if (quads.length > 0) {
            this.state.add(member.value);
            return memberFromQuads(member, quads, this.timestampPath, this.isVersionOfPath);
        }
    }
    /// Only listen to this promise if a member is queued
    reset() {
        const logger = log.extend("reset");
        logger("Resetting with %d members in queue", this.queued);
        this.queued = 0;
        return new Promise((res) => (this.resolve = res));
    }
}
