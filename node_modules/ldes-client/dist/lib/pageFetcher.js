import { extractRelations } from "./page.js";
import debug from "debug";
import { RdfStore } from "rdf-stores";
import { DataFactory } from "rdf-data-factory";
const log = debug("fetcher");
const { namedNode } = new DataFactory();
export function longPromise() {
    const out = {};
    out.waiting = new Promise((res) => (out.callback = res));
    return out;
}
export function resetPromise(promise) {
    const cb = promise.callback;
    promise.waiting = new Promise((res) => (promise.callback = res));
    cb();
}
export class Fetcher {
    dereferencer;
    loose;
    fetch_f;
    condition;
    closed = false;
    constructor(dereferencer, loose, condition, fetch_f) {
        this.dereferencer = dereferencer;
        this.loose = loose;
        this.fetch_f = fetch_f;
        this.condition = condition;
    }
    close() {
        this.closed = true;
    }
    async fetch(node, state, notifier) {
        const logger = log.extend("fetch");
        try {
            const resp = await this.dereferencer.dereference(node.target, {
                localFiles: true,
                fetch: this.fetch_f,
            });
            node.target = resp.url;
            const cache = {};
            if (resp.headers) {
                const cacheControlCandidate = resp.headers.get("cache-control");
                if (cacheControlCandidate) {
                    const controls = cacheControlCandidate
                        .split(",")
                        .map((x) => x.split("=", 2).map((x) => x.trim()));
                    for (let control of controls) {
                        if (control[0] == "max-age") {
                            cache.maxAge = parseInt(control[1]);
                        }
                        if (control[0] == "immutable") {
                            cache.immutable = true;
                        }
                    }
                }
            }
            if (!cache.immutable) {
                if (!this.closed) {
                    notifier.scheduleFetch(node, state);
                }
            }
            logger("Cache for  %s %o", node.target, cache);
            const data = RdfStore.createDefault();
            let quadCount = 0;
            await new Promise((resolve, reject) => {
                resp.data
                    .on("data", (quad) => {
                    data.addQuad(quad);
                    quadCount++;
                })
                    .on("end", resolve)
                    .on("error", reject);
            });
            logger("Got data %s (%d quads)", node.target, quadCount);
            for (let rel of extractRelations(data, namedNode(resp.url), this.loose, this.condition)) {
                if (!node.expected.some((x) => x == rel.node)) {
                    if (!this.closed) {
                        notifier.relationFound({ from: node, target: rel }, state);
                    }
                }
            }
            if (!this.closed) {
                notifier.pageFetched({ data, url: resp.url }, state);
            }
        }
        catch (ex) {
            logger("Fetch failed %o", ex);
            notifier.error(ex, state);
        }
    }
}
