import { RDF, TREE } from "@treecg/types";
import { getObjects, memberFromQuads } from "./utils.js";
import { RelationCondition } from "./condition/range.js";
export function extractMembers(store, stream, extractor, state, cb, shapeId, timestampPath, isVersionOfPath) {
    const members = getObjects(store, stream, TREE.terms.member, null);
    async function extractMember(member) {
        const quads = await extractor.extract(store, member, shapeId);
        cb(memberFromQuads(member, quads, timestampPath, isVersionOfPath));
    }
    const out = [];
    for (let member of members) {
        if (!state.seen(member.value)) {
            state.add(member.value);
            out.push(extractMember(member));
        }
    }
    return out;
}
export function extractRelations(store, node, loose, condition) {
    const relationIds = loose
        ? getObjects(store, null, TREE.terms.relation, null)
        : getObjects(store, node, TREE.terms.relation, null);
    const source = node.value;
    const conditions = new Map();
    // Set of tree:Nodes that are to be skipped based on temporal constraints.
    // Necessary when there is more than one relation type pointing towards the same node
    const filteredNodes = new Set();
    const allowedNodes = new Map();
    for (let relationId of relationIds) {
        const node = getObjects(store, relationId, TREE.terms.node, null)[0];
        if (!conditions.get(node.value)) {
            const node = getObjects(store, relationId, TREE.terms.node, null)[0];
            const ty = getObjects(store, relationId, RDF.terms.type, null)[0] || TREE.Relation;
            const path = getObjects(store, relationId, TREE.terms.path, null)[0];
            const value = getObjects(store, relationId, TREE.terms.value, null);
            const relation = {
                source,
                node: node.value,
                type: ty,
                path,
                value,
                id: relationId,
            };
            conditions.set(node.value, {
                cond: new RelationCondition(store),
                relation,
            });
        }
        conditions.get(node.value).cond.addRelation(relationId);
    }
    const allowed = [];
    for (let cond of conditions.values()) {
        if (cond.cond.allowed(condition)) {
            allowed.push(cond.relation);
        }
    }
    console.log("allowed", allowed.map(x => x.node));
    return allowed;
}
