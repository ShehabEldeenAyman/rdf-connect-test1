import { Config } from "./config.js";
import { Member } from "./page.js";
import { RdfDereferencer } from "rdf-dereference";
import { CBDShapeExtractor } from "extract-cbd-shape";
import { Term } from "@rdfjs/types";
import { ModulatorFactory } from "./utils.js";
import type { Writer } from "@ajuvercr/js-runner";
export { intoConfig } from "./config.js";
export { extractMainNodeShape, retry_fetch } from "./utils.js";
export { Condition, empty_condition, parse_condition, Range, } from "./condition/index.js";
export type { Member, Page, Relation } from "./page.js";
export type { Config, ShapeConfig } from "./config.js";
export type Ordered = "ascending" | "descending" | "none";
export declare function replicateLDES(config: Partial<Config> & {
    url: string;
}, ordered?: Ordered, dereferencer?: RdfDereferencer, streamId?: Term): Client;
export type LDESInfo = {
    shape: Term;
    extractor: CBDShapeExtractor;
    timestampPath?: Term;
    isVersionOfPath?: Term;
};
type EventMap = Record<string, any>;
type EventKey<T extends EventMap> = string & keyof T;
type EventReceiver<T> = (params: T) => void;
export type ClientEvents = {
    fragment: void;
    mutable: void;
    poll: void;
    error: any;
};
export declare class Client {
    private config;
    private dereferencer;
    private fetcher;
    private memberManager;
    private strategy;
    streamId?: Term;
    private ordered;
    private modulatorFactory;
    private stateFactory;
    private listeners;
    constructor(config: Config, ordered?: Ordered, dereferencer?: RdfDereferencer, stream?: Term);
    on<K extends EventKey<ClientEvents>>(key: K, fn: EventReceiver<ClientEvents[K]>): void;
    private emit;
    init(emit: (member: Member) => void, close: () => void, factory: ModulatorFactory): Promise<void>;
    stream(strategy?: {
        highWaterMark?: number;
        size?: (chunk: Member) => number;
    }): ReadableStream<Member>;
}
export declare function processor(writer: Writer<string>, url: string, before?: Date, after?: Date, ordered?: string, follow?: boolean, pollInterval?: number, shape?: string, noShape?: boolean, save?: string, loose?: boolean, urlIsView?: boolean, verbose?: boolean, fetch_config?: {
    auth?: {
        type: "basic";
        auth: string;
        host: string;
    };
    concurrent?: number;
    retry?: {
        codes: number[];
        maxRetries: number;
    };
}): Promise<() => Promise<void>>;
