'use strict';

var n3 = require('n3');
var rdfLens = require('rdf-lens');
var rdfStores = require('rdf-stores');
var types = require('@treecg/types');
var debug = require('debug');
var rdfDereference = require('rdf-dereference');
var extractCbdShape = require('extract-cbd-shape');
var rdfDataFactory = require('rdf-data-factory');
var Heap = require('heap-js');

const SHAPES = `
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix sh: <http://www.w3.org/ns/shacl#>.
@prefix tree: <https://w3id.org/tree#>.
@prefix rdfl: <https://w3id.org/rdf-lens/ontology#>.

[ ] a sh:NodeShape;
  sh:targetClass _:rdfThing;
  sh:property [
    sh:path ( );
    sh:datatype xsd:iri;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "entry";
  ], [
    sh:path ( );
    sh:class rdfl:CBD;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "quads";
  ].

[ ] a sh:NodeShape;
  sh:targetClass tree:And;
  sh:property [
    sh:path tree:alpha;
    sh:class rdfl:TypedExtract;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "alpha";
  ], [
    sh:path tree:beta;
    sh:class rdfl:TypedExtract;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "beta";
  ].

[ ] a sh:NodeShape;
  sh:targetClass tree:Or;
  sh:property [
    sh:path tree:alpha;
    sh:class rdfl:TypedExtract;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "alpha";
  ], [
    sh:path tree:beta;
    sh:class rdfl:TypedExtract;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "beta";
  ].

[ ] a sh:NodeShape;
  sh:targetClass tree:Condition;
  sh:property [
    sh:path tree:relationType;
    sh:datatype xsd:iri;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "relationType";
  ], [
    sh:path tree:path;
    sh:class _:rdfThing;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "pathQuads";
  ], [
    sh:path tree:path;
    sh:class rdfl:PathLens;
    sh:maxCount 1;
    sh:minCount 1;
    sh:name "path";
  ], [
    sh:path tree:value;
    sh:datatype xsd:string;
    sh:maxCount 1;
    sh:name "value";
  ], [
    sh:path tree:compareType;
    sh:datatype xsd:string;
    sh:name "compareType";
    sh:maxCount 1;
    sh:in ("string" "date" "integer" "float");
  ].
`;

function getSubjects(store, predicate, object, graph) {
    return store.getQuads(null, predicate, object, graph).map((quad) => {
        return quad.subject;
    });
}
function getObjects(store, subject, predicate, graph) {
    return store.getQuads(subject, predicate, null, graph).map((quad) => {
        return quad.object;
    });
}
/**
 * Converts a stream to an array, pushing all elements to an array
 * Resolving the promise with the 'end' event
 */
function streamToArray(stream) {
    const out = [];
    return new Promise(async (res, rej) => {
        stream.on("end", () => res(out));
        stream.on("data", (x) => {
            out.push(x);
        });
        stream.on("error", (ex) => {
            console.error("Stream to Array failed");
            rej(ex);
        });
    });
}
/**
 * Find the main sh:NodeShape subject of a given Shape Graph.
 * We determine this by assuming that the main node shape
 * is not referenced by any other shape description.
 * If more than one is found an exception is thrown.
 */
function extractMainNodeShape(store) {
    const nodeShapes = getSubjects(store, types.RDF.terms.type, types.SHACL.terms.NodeShape, null);
    let mainNodeShape = null;
    if (nodeShapes && nodeShapes.length > 0) {
        for (const ns of nodeShapes) {
            const isNotReferenced = getSubjects(store, null, ns, null).length === 0;
            if (isNotReferenced) {
                if (!mainNodeShape) {
                    mainNodeShape = ns;
                }
                else {
                    throw new Error("There are multiple main node shapes in a given shape graph. Unrelated shapes must be given as separate shape graphs");
                }
            }
        }
        if (mainNodeShape) {
            return mainNodeShape;
        }
        else {
            throw new Error("No main SHACL Node Shapes found in given shape graph");
        }
    }
    else {
        throw new Error("No SHACL Node Shapes found in given shape graph");
    }
}
/**
 * Factory that creates Modulator's
 * This is a factory to keep track whether or not the Modulator should be paused or not.
 */
class ModulatorFactory {
    concurrent = 10;
    paused = false;
    factory;
    children = [];
    constructor(stateFactory, concurrent) {
        this.factory = stateFactory;
        if (concurrent) {
            this.concurrent = concurrent;
        }
    }
    /**
     * Note: `T` should be plain javascript objects (because that how state is saved)
     */
    create(name, ranker, notifier, parse) {
        const state = this.factory.build(name, JSON.stringify, JSON.parse, () => ({
            todo: [],
            inflight: [],
        }));
        if (parse) {
            state.item.todo = state.item.todo.map(({ item, index }) => ({
                index,
                item: parse(item),
            }));
            state.item.inflight = state.item.inflight.map(({ item, index }) => ({
                index,
                item: parse(item),
            }));
        }
        const modulator = new ModulatorInstance(state, ranker, notifier, this);
        this.children.push(modulator);
        return modulator;
    }
    pause() {
        this.paused = true;
    }
    unpause() {
        this.paused = false;
        this.children.forEach((x) => x.checkReady());
    }
}
class ModulatorInstance {
    at = 0;
    index = 0;
    state;
    ranker;
    notifier;
    factory;
    constructor(state, ranker, notifier, factory) {
        this.state = state;
        const readd = [...this.state.item.todo, ...this.state.item.inflight];
        this.state.item.todo.push(...this.state.item.inflight);
        while (this.state.item.inflight.pop()) { }
        while (this.state.item.todo.pop()) { }
        this.ranker = ranker;
        this.notifier = notifier;
        this.factory = factory;
        for (let item of readd) {
            this.push(item.item);
        }
    }
    length() {
        return this.state.item.todo.length;
    }
    push(item) {
        const indexed = { item, index: this.index };
        this.state.item.todo.push(indexed);
        this.index += 1;
        this.ranker.push(indexed);
        this.checkReady();
    }
    finished(index) {
        const removeIdx = this.state.item.inflight.findIndex((x) => x.index == index);
        if (removeIdx >= 0) {
            this.state.item.inflight.splice(removeIdx, 1);
        }
        else {
            console.error("Expected to be able to remove inflight item");
        }
        this.at -= 1;
        this.checkReady();
    }
    checkReady() {
        if (this.factory.paused) {
            return;
        }
        while (this.at < this.factory.concurrent) {
            const item = this.ranker.pop();
            if (item) {
                // This item is no longer todo
                // I'm quite afraid to use filter for this
                const removeIdx = this.state.item.todo.findIndex((x) => x.index == item.index);
                if (removeIdx >= 0) {
                    this.state.item.todo.splice(removeIdx, 1);
                }
                else {
                    console.error("Expected to be able to remove inflight item");
                }
                // This item is now inflight
                this.state.item.inflight.push(item);
                this.at += 1;
                this.notifier.ready(item, {});
            }
            else {
                break;
            }
        }
    }
}
function urlToUrl(input) {
    if (typeof input === "string") {
        return new URL(input);
    }
    else if (input instanceof URL) {
        return input;
    }
    else if (input instanceof Request) {
        return new URL(input.url);
    }
    else {
        throw "Not a real url";
    }
}
const log$5 = debug("fetch");
function enhanced_fetch(config, start) {
    const start_f = fetch;
    const safe_f = config.safe
        ? (async (a, b) => {
            while (true) {
                try {
                    return await start_f(a, b);
                }
                catch (ex) {
                    console.error("This should not happen, it will not happen this is saf", ex);
                }
            }
        })
        : start_f;
    const fetch_f = config.auth ? handle_basic_auth(safe_f, config.auth) : safe_f;
    return limit_fetch_per_domain(retry_fetch(fetch_f, config.retry || {}), config.concurrent);
}
function limit_fetch_per_domain(fetch_f, concurrent = 10) {
    const logger = log$5.extend("limit");
    const domain_dict = {};
    const out = async (input, init) => {
        let url = urlToUrl(input);
        const domain = url.origin;
        if (!(domain in domain_dict)) {
            domain_dict[domain] = [];
        }
        const requests = domain_dict[domain];
        await new Promise((res) => {
            logger("%s capacity %d/%d", domain, requests.length, concurrent);
            if (requests.length < concurrent) {
                requests.push(res);
                res({});
            }
            else {
                requests.push(res);
            }
        });
        const resp = await fetch_f(input, init);
        requests.shift();
        for (let i = 0; i < concurrent; i++) {
            if (requests[i]) {
                requests[i]();
            }
        }
        return resp;
    };
    return out;
}
function handle_basic_auth(fetch_f, config) {
    const logger = log$5.extend("auth");
    let authRequired = false;
    const basicAuthValue = `Basic ${Buffer.from(config.auth).toString("base64")}`;
    const setHeader = (init) => {
        const reqInit = init || {};
        const headers = new Headers(reqInit.headers);
        headers.set("Authorization", basicAuthValue);
        reqInit.headers = headers;
        return reqInit;
    };
    const auth_f = async (input, init) => {
        let url = urlToUrl(input);
        if (authRequired && url.host === config.host) {
            return await fetch_f(input, setHeader(init));
        }
        const resp = await fetch_f(input, init);
        if (resp.status === 401) {
            logger("Unauthorized, adding basic auth");
            if (url.host === config.host) {
                authRequired = true;
                return await fetch_f(input, setHeader(init));
            }
        }
        return resp;
    };
    return auth_f;
}
function retry_fetch(fetch_f, partial_config) {
    const config = Object.assign({
        codes: [408, 425, 429, 500, 502, 503, 504],
        base: 500,
        maxRetries: 5,
    }, partial_config);
    const logger = log$5.extend("retry");
    const retry = async (input, init) => {
        let tryCount = 0;
        let retryTime = config.maxRetries;
        while (config.maxRetries == 0 || tryCount < config.maxRetries) {
            const resp = await fetch_f(input, init);
            if (!resp.ok) {
                if (config.codes.some((x) => x == resp.status)) {
                    logger("Retry %s %d/%d", input, tryCount, config.maxRetries);
                    // Wait 500ms, 1 second, 2 seconds, 4 seconds, 8 seconds, fail
                    tryCount += 1;
                    await new Promise((res) => setTimeout(res, retryTime));
                    retryTime *= 2;
                    continue;
                }
                return resp;
            }
            return resp;
        }
        throw `Max retries exceeded (${config.maxRetries})`;
    };
    return retry;
}
function memberFromQuads(member, quads, timestampPath, isVersionOfPath) {
    // Get timestamp
    let timestamp;
    if (timestampPath) {
        const ts = quads.find((x) => x.subject.equals(member) && x.predicate.equals(timestampPath))?.object.value;
        if (ts) {
            try {
                timestamp = new Date(ts);
            }
            catch (ex) {
                timestamp = ts;
            }
        }
    }
    // Get isVersionof
    let isVersionOf;
    if (isVersionOfPath) {
        isVersionOf = quads.find((x) => x.subject.equals(member) && x.predicate.equals(isVersionOfPath))?.object.value;
    }
    // Get type
    let type;
    type = quads.find((x) => x.subject.equals(member) && x.predicate.value === types.RDF.type)?.object;
    return { quads, id: member, isVersionOf, timestamp, type };
}

function cbdEquals(a, b) {
    const sort = (a, b) => {
        const ap = a.predicate.value;
        const bp = b.predicate.value;
        if (ap == bp)
            return 0;
        return ap < bp ? -1 : 1;
    };
    const alphaQuads = a.store.getQuads(a.id, null, null, null).sort(sort);
    const betaQuads = b.store.getQuads(b.id, null, null, null).sort(sort);
    if (alphaQuads.length != betaQuads.length)
        return false;
    for (let i = 0; i < alphaQuads.length; i++) {
        if (!alphaQuads[i].predicate.equals(betaQuads[i].predicate))
            return false;
        const av = alphaQuads[i].object;
        const bv = betaQuads[i].object;
        if (av.termType !== bv.termType)
            return false;
        if (av.termType === "BlankNode") {
            if (!cbdEquals({ id: av, store: a.store }, { id: bv, store: b.store })) {
                return false;
            }
        }
        else {
            if (av.value !== bv.value) {
                return false;
            }
        }
    }
    return true;
}
class RelationCondition {
    store;
    ranges = [];
    constructor(store) {
        this.store = store;
    }
    allowed(condition) {
        return this.ranges.every((x) => {
            if (!x.range) {
                console.log("range is undefined!", condition);
            }
            return condition.matchRelation(x.range, { id: x.cbdEntry, store: this.store });
        });
    }
    addRelation(relationId) {
        const ty = getObjects(this.store, relationId, types.RDF.terms.type, null)[0] ||
            types.TREE.Relation;
        const path = getObjects(this.store, relationId, types.TREE.terms.path, null)[0];
        const value = getObjects(this.store, relationId, types.TREE.terms.value, null)[0];
        console.log("Add relation", { ty, path, value });
        let range = this.ranges.find((range) => cbdEquals({ id: path, store: this.store }, { id: range.cbdEntry, store: this.store }));
        if (!range) {
            const newRange = {
                cbdEntry: path,
                range: Range.empty(),
            };
            this.ranges.push(newRange);
            range = newRange;
        }
        if (!value) {
            range.range = undefined;
            return;
        }
        range.range?.add(value.value, ty.value);
    }
}

function empty_condition() {
    return new EmptyCondition();
}
function parse_condition(source, baseIRI) {
    const shapeQuads = new n3.Parser().parse(SHAPES);
    const output = rdfLens.extractShapes(shapeQuads, {
        "https://w3id.org/tree#And": (obj) => new AndCondition(obj),
        "https://w3id.org/tree#Or": (obj) => new OrCondition(obj),
        "https://w3id.org/tree#Condition": (obj) => new LeafCondition(obj),
    });
    const dataQuads = new n3.Parser({ baseIRI: baseIRI }).parse(source);
    return output.lenses["https://w3id.org/rdf-lens/ontology#TypedExtract"].execute({
        quads: dataQuads,
        id: new n3.NamedNode(baseIRI),
    });
}
class Range {
    min;
    eqMin = true;
    max;
    eqMax = true;
    constructor(value, type) {
        switch (type) {
            case types.TREE.EqualToRelation:
                this.min = value;
                this.max = value;
                return;
            case types.TREE.LessThanRelation:
                this.max = value;
                this.eqMax = false;
                return;
            case types.TREE.LessThanOrEqualToRelation:
                this.max = value;
                return;
            case types.TREE.GreaterThanRelation:
                this.min = value;
                this.eqMin = false;
                return;
            case types.TREE.GreaterThanOrEqualToRelation:
                this.min = value;
                return;
        }
    }
    add(value, type) {
        switch (type) {
            case types.TREE.EqualToRelation:
                this.min = value;
                this.max = value;
                return;
            case types.TREE.LessThanRelation:
                if (!this.max || value < this.max) {
                    this.max = value;
                    this.eqMax = false;
                }
                return;
            case types.TREE.LessThanOrEqualToRelation:
                if (!this.max || value < this.max) {
                    this.max = value;
                }
                return;
            case types.TREE.GreaterThanRelation:
                if (!this.min || value > this.min) {
                    this.min = value;
                    this.eqMin = false;
                }
                return;
            case types.TREE.GreaterThanOrEqualToRelation:
                if (!this.min || value > this.min) {
                    this.min = value;
                }
                return;
        }
    }
    static empty() {
        return new Range(null, types.TREE.Relation);
    }
    contains(value) {
        if (this.min) {
            if (this.eqMin) {
                if (this.min > value)
                    return false;
            }
            else {
                if (this.min >= value)
                    return false;
            }
        }
        if (this.max) {
            if (this.eqMax) {
                if (this.max < value)
                    return false;
            }
            else {
                if (this.max <= value)
                    return false;
            }
        }
        return true;
    }
    overlaps(other) {
        if (this.min && other.max) {
            if (this.eqMin && other.eqMax) {
                if (this.min > other.max)
                    return false;
            }
            else {
                if (this.min >= other.max)
                    return false;
            }
        }
        if (this.max && other.min) {
            if (this.eqMax && other.eqMin) {
                if (other.min > this.max)
                    return false;
            }
            else {
                if (other.min >= this.max)
                    return false;
            }
        }
        return true;
    }
    toString(valueToString) {
        const vts = valueToString || ((x) => x.toString());
        const comma = !!this.min && !!this.max ? "," : "";
        const start = this.min ? (this.eqMin ? "[" : "(") + vts(this.min) : "]";
        const end = this.max ? vts(this.max) + (this.eqMax ? "]" : ")") : "[";
        return start + comma + end;
    }
}
class LeafCondition {
    relationType;
    value;
    compareType;
    path;
    pathQuads;
    range;
    constructor(inp) {
        this.relationType = inp.relationType;
        this.value = inp.value;
        this.compareType = inp.compareType || "string";
        this.path = inp.path;
        const store = rdfStores.RdfStore.createDefault();
        inp.pathQuads.quads.forEach((x) => store.addQuad(x));
        this.pathQuads = { id: inp.pathQuads.entry, store };
        this.range = new Range(this.parseValue(inp.value), inp.relationType.value);
    }
    toString() {
        const vts = this.compareType === "date" ? (x) => x.toISOString() : undefined;
        return `${this.pathQuads.id.value} âˆˆ ${this.range.toString(vts)}`;
    }
    parseValue(value) {
        switch (this.compareType) {
            case "string":
                return value;
            case "date":
                return new Date(value);
            case "integer":
                return parseInt(value);
            case "float":
                return parseFloat(value);
            default:
                return value;
        }
    }
    matchRelation(range, cbdId, verbose) {
        if (!cbdEquals(this.pathQuads, cbdId)) {
            return true;
        }
        if (!range)
            console.log("Rangee is here also undefined, returning false");
        if (!range)
            return false;
        if (verbose) {
            const vts = this.compareType === "date" ? (x) => x.toISOString() : undefined;
            console.log(this.range.toString(vts), "contains", range.toString(vts), this.range.overlaps(range));
        }
        return this.range.overlaps(range);
    }
    matchMember(member) {
        const value = this.parseValue(this.path.execute(member)[0].id.value);
        return this.range.contains(value);
    }
}
class BiCondition {
    alpha;
    beta;
    constructor(inp) {
        this.alpha = inp.alpha;
        this.beta = inp.beta;
    }
    matchRelation(range, cbdId, verbose) {
        const alpha = this.alpha.matchRelation(range, cbdId, verbose);
        const beta = this.beta.matchRelation(range, cbdId, verbose);
        if (verbose) {
            console.log(">", this.combine(alpha, beta));
        }
        return this.combine(alpha, beta);
    }
    matchMember(member) {
        const alpha = this.alpha.matchMember(member);
        const beta = this.beta.matchMember(member);
        return this.combine(alpha, beta);
    }
}
class AndCondition extends BiCondition {
    combine(alpha, beta) {
        return alpha && beta; // TODO those might be null if something cannot make a statement about it, important for not condition
    }
    toString() {
        return `(${this.alpha.toString()} ^ ${this.beta.toString()})`;
    }
}
class OrCondition extends BiCondition {
    combine(alpha, beta) {
        return alpha || beta; // TODO those might be null if something cannot make a statement about it, important for not condition
    }
    toString() {
        return `(${this.alpha.toString()} V ${this.beta.toString()})`;
    }
}
class EmptyCondition {
    matchRelation(_range, _cbdId, verbose) {
        if (verbose)
            console.log("Returning true");
        return true;
    }
    matchMember(_member) {
        return true;
    }
    toString() {
        return "all";
    }
}

const defaultConfig = {
    urlIsView: false,
    noShape: false,
    condition: empty_condition(),
    loose: false,
    polling: false,
    url: "",
    pollInterval: 200,
};
const defaultTarget = {
    target: {},
};
function intoConfig(config) {
    return Object.assign({}, defaultConfig, defaultTarget, config);
}

// myLibrary.ts
let storage;
if (typeof window === "undefined") {
    // Node.js environment
    let fs;
    if (typeof require === "undefined") {
        import('fs').then(mod => fs = mod);
    }
    else {
        fs = require("fs");
    }
    storage = {
        getItem: (key) => {
            const data = fs.readFileSync(key, "utf8");
            return data;
        },
        setItem: (key, value) => {
            fs.writeFileSync(key, value, "utf8");
        },
        removeItem: (key) => {
            try {
                fs.unlinkSync(key);
            }
            catch (error) {
                // Handle error
            }
        },
    };
}
else {
    // Browser environment
    storage = {
        getItem: (key) => {
            const data = localStorage.getItem(key);
            if (data)
                return data;
            throw "Key not found in local storage";
        },
        setItem: (key, value) => {
            localStorage.setItem(key, value);
        },
        removeItem: (key) => {
            localStorage.removeItem(key);
        },
    };
}

class NoStateFactory {
    build(_name, _serialize, deserialize, create) {
        return new StateT(deserialize, create);
    }
    write() {
    }
}
class FileStateFactory {
    location;
    elements;
    found;
    constructor(location) {
        this.location = location;
        this.elements = [];
        this.found = {};
        try {
            const item = storage.getItem(location);
            this.found = JSON.parse(item);
        }
        catch (ex) { }
    }
    write() {
        const out = {};
        for (let element of this.elements) {
            out[element.name] = element.serialize(element.state.item);
        }
        storage.setItem(this.location, JSON.stringify(out));
    }
    build(name, serialize, deserialize, create) {
        const out = this.elements.find((x) => x.name == name);
        if (out)
            return out.state;
        const found = this.found[name];
        const state = new StateT(deserialize, create, found);
        this.elements.push({
            name,
            serialize,
            state,
        });
        return state;
    }
}
class StateT {
    item;
    constructor(deserialize, create, prev) {
        const item = prev ? deserialize(prev) : create();
        if (item) {
            this.item = item;
        }
        else {
            this.item = create();
        }
    }
}

function extractRelations(store, node, loose, condition) {
    const relationIds = loose
        ? getObjects(store, null, types.TREE.terms.relation, null)
        : getObjects(store, node, types.TREE.terms.relation, null);
    const source = node.value;
    const conditions = new Map();
    for (let relationId of relationIds) {
        const node = getObjects(store, relationId, types.TREE.terms.node, null)[0];
        if (!conditions.get(node.value)) {
            const node = getObjects(store, relationId, types.TREE.terms.node, null)[0];
            const ty = getObjects(store, relationId, types.RDF.terms.type, null)[0] || types.TREE.Relation;
            const path = getObjects(store, relationId, types.TREE.terms.path, null)[0];
            const value = getObjects(store, relationId, types.TREE.terms.value, null);
            const relation = {
                source,
                node: node.value,
                type: ty,
                path,
                value,
                id: relationId,
            };
            conditions.set(node.value, {
                cond: new RelationCondition(store),
                relation,
            });
        }
        conditions.get(node.value).cond.addRelation(relationId);
    }
    const allowed = [];
    for (let cond of conditions.values()) {
        if (cond.cond.allowed(condition)) {
            allowed.push(cond.relation);
        }
    }
    console.log("allowed", allowed.map(x => x.node));
    return allowed;
}

const log$4 = debug("fetcher");
const { namedNode } = new rdfDataFactory.DataFactory();
function longPromise() {
    const out = {};
    out.waiting = new Promise((res) => (out.callback = res));
    return out;
}
function resetPromise(promise) {
    const cb = promise.callback;
    promise.waiting = new Promise((res) => (promise.callback = res));
    cb();
}
class Fetcher {
    dereferencer;
    loose;
    fetch_f;
    condition;
    closed = false;
    constructor(dereferencer, loose, condition, fetch_f) {
        this.dereferencer = dereferencer;
        this.loose = loose;
        this.fetch_f = fetch_f;
        this.condition = condition;
    }
    close() {
        this.closed = true;
    }
    async fetch(node, state, notifier) {
        const logger = log$4.extend("fetch");
        try {
            const resp = await this.dereferencer.dereference(node.target, {
                localFiles: true,
                fetch: this.fetch_f,
            });
            node.target = resp.url;
            const cache = {};
            if (resp.headers) {
                const cacheControlCandidate = resp.headers.get("cache-control");
                if (cacheControlCandidate) {
                    const controls = cacheControlCandidate
                        .split(",")
                        .map((x) => x.split("=", 2).map((x) => x.trim()));
                    for (let control of controls) {
                        if (control[0] == "max-age") {
                            cache.maxAge = parseInt(control[1]);
                        }
                        if (control[0] == "immutable") {
                            cache.immutable = true;
                        }
                    }
                }
            }
            if (!cache.immutable) {
                if (!this.closed) {
                    notifier.scheduleFetch(node, state);
                }
            }
            logger("Cache for  %s %o", node.target, cache);
            const data = rdfStores.RdfStore.createDefault();
            let quadCount = 0;
            await new Promise((resolve, reject) => {
                resp.data
                    .on("data", (quad) => {
                    data.addQuad(quad);
                    quadCount++;
                })
                    .on("end", resolve)
                    .on("error", reject);
            });
            logger("Got data %s (%d quads)", node.target, quadCount);
            for (let rel of extractRelations(data, namedNode(resp.url), this.loose, this.condition)) {
                if (!node.expected.some((x) => x == rel.node)) {
                    if (!this.closed) {
                        notifier.relationFound({ from: node, target: rel }, state);
                    }
                }
            }
            if (!this.closed) {
                notifier.pageFetched({ data, url: resp.url }, state);
            }
        }
        catch (ex) {
            logger("Fetch failed %o", ex);
            notifier.error(ex, state);
        }
    }
}

const log$3 = debug("manager");
class Manager {
    queued = 0;
    closed = false;
    resolve;
    ldesId;
    state;
    extractor;
    shapeId;
    timestampPath;
    isVersionOfPath;
    constructor(ldesId, state, info) {
        const logger = log$3.extend("constructor");
        this.ldesId = ldesId;
        this.state = state;
        this.extractor = info.extractor;
        this.timestampPath = info.timestampPath;
        this.isVersionOfPath = info.isVersionOfPath;
        this.shapeId = info.shape;
        logger("new %s %o", ldesId.value, info);
    }
    // Extract members found in this page, this does not yet emit the members
    extractMembers(page, state, notifier) {
        const logger = log$3.extend("extract");
        const members = getObjects(page.data, this.ldesId, types.TREE.terms.member, null);
        logger("%d members", members.length);
        const promises = [];
        for (let member of members) {
            if (!this.state.has(member.value)) {
                const promise = this.extractMember(member, page.data)
                    .then((member) => {
                    if (member) {
                        if (!this.closed) {
                            notifier.extracted(member, state);
                        }
                    }
                    return member;
                })
                    .catch((ex) => {
                    logger("Error %o", ex);
                    notifier.error({ error: ex, type: "extract", memberId: member }, state);
                    var err = new Error();
                    console.log(err.stack);
                });
                promises.push(promise);
            }
        }
        Promise.all(promises).then((members) => {
            logger("All members extracted");
            if (!this.closed) {
                notifier.done(members.flatMap((x) => (x ? [x] : [])), state);
            }
        });
    }
    close() {
        log$3("Closing");
        if (this.resolve) {
            this.resolve();
            this.resolve = undefined;
        }
        this.closed = true;
        log$3("this.resolve()");
    }
    length() {
        return this.state.size;
    }
    async extractMemberQuads(member, data) {
        return await this.extractor.extract(data, member, this.shapeId);
    }
    async extractMember(member, data) {
        if (this.state.has(member.value))
            return;
        const quads = await this.extractMemberQuads(member, data);
        if (quads.length > 0) {
            this.state.add(member.value);
            return memberFromQuads(member, quads, this.timestampPath, this.isVersionOfPath);
        }
    }
    /// Only listen to this promise if a member is queued
    reset() {
        const logger = log$3.extend("reset");
        logger("Resetting with %d members in queue", this.queued);
        this.queued = 0;
        return new Promise((res) => (this.resolve = res));
    }
}

const log$2 = debug("strategy");
class UnorderedStrategy {
    manager;
    fetcher;
    notifier;
    inFlight = 0;
    fetchNotifier;
    memberNotifier;
    modulator;
    cacheList = [];
    polling;
    pollInterval;
    cancled = false;
    constructor(memberManager, fetcher, notifier, modulatorFactory, polling, pollInterval) {
        this.pollInterval = pollInterval;
        this.notifier = notifier;
        this.manager = memberManager;
        this.fetcher = fetcher;
        this.polling = polling;
        const fetchLogger = log$2.extend("fetch");
        // Callbacks for the fetcher
        // - seen: the strategy wanted to fetch an uri, but it was already seen
        //         so one fetch request is terminated, inFlight -= 1
        // - pageFetched: a complete page is fetched and the relations have been extracted
        //         start member extraction
        // - relationFound: a relation has been found, inFlight += 1 and put it in the queue
        this.fetchNotifier = {
            error: (error) => {
                fetchLogger("error %o", error);
                this.notifier.error(error, {});
            },
            scheduleFetch: (node) => {
                this.cacheList.push(node);
                this.notifier.mutable({}, {});
            },
            pageFetched: (page, { index }) => {
                fetchLogger("Paged fetched %s", page.url);
                this.handleFetched(page, index);
            },
            relationFound: ({ from, target }) => {
                from.expected.push(target.node);
                this.inFlight += 1;
                this.modulator.push({ target: target.node, expected: [from.target] });
            },
        };
        const memberLogger = log$2.extend("member");
        // Callbacks for the member extractor
        // - done: all members have been extracted, we are finally done with a page inFlight -= 1
        // - extracted: a member has been found, yeet it
        this.memberNotifier = {
            error: (error) => {
                this.notifier.error(error, {});
            },
            done: () => {
                memberLogger("Members on page done");
                this.inFlight -= 1;
                this.checkEnd();
                this.notifier.fragment({}, {});
            },
            extracted: (mem) => this.notifier.member(mem, {}),
        };
        this.modulator = modulatorFactory.create("fetcher", [], {
            ready: ({ item, index }) => this.fetcher.fetch(item, { index }, this.fetchNotifier),
        });
    }
    start(url) {
        const logger = log$2.extend("start");
        this.inFlight = this.modulator.length();
        if (this.inFlight < 1) {
            this.inFlight = 1;
            this.modulator.push({ target: url, expected: [] });
            logger("Nothing in flight, adding start url");
        }
        else {
            logger("Things are already inflight, not adding start url");
        }
    }
    cancel() {
        this.cancled = true;
    }
    handleFetched(page, index) {
        this.modulator.finished(index);
        this.manager.extractMembers(page, {}, this.memberNotifier);
    }
    checkEnd() {
        if (this.cancled)
            return;
        if (this.inFlight == 0) {
            if (this.polling) {
                setTimeout(() => {
                    if (this.cancled)
                        return;
                    this.notifier.pollCycle({}, {});
                    const cl = this.cacheList.slice();
                    this.cacheList = [];
                    for (let cache of cl) {
                        this.inFlight += 1;
                        this.modulator.push(cache);
                    }
                }, this.pollInterval || 1000);
            }
            else {
                log$2("Closing the notifier, polling is not set");
                this.cancled = true;
                this.notifier.close({}, {});
            }
        }
    }
}

/**
 * This relation chain is important to better understand the order of fragments to fetch
 * First fetch all not important relations
 * Then fetch an important relation with the smallest value (for timestamp path)
 * This new relation can access other unimportant relations, but these should only be fetched after full unimportant relation chains
 */
class RelationChain {
    source;
    relations;
    target;
    cmp;
    constructor(source, target, relations = [], additional, cmp) {
        this.source = source;
        this.target = target;
        this.cmp = cmp;
        this.relations = relations.map(({ value, important }) => ({
            value,
            important,
        }));
        if (additional) {
            this.relations.push(additional);
            while (this.relations.length >= 2) {
                // Second to last element
                const a = this.relations[this.relations.length - 2];
                // Last element
                const b = this.relations[this.relations.length - 1];
                if (a.important && !b.important) {
                    break; // This cannot be compacted
                }
                // A and B are important, compact on value
                if (a.important) {
                    const va = a.value;
                    const vb = b.value;
                    if (this.cmp) {
                        if (this.cmp(va, vb) < 0) {
                            a.value = b.value;
                        }
                    }
                    else {
                        a.value = va < vb ? va : vb;
                    }
                }
                else {
                    // a is not important, so we can just take b values
                    a.important = b.important;
                    a.value = b.value;
                }
                this.relations.pop();
            }
        }
    }
    push(target, relation) {
        return new RelationChain(this.target, target, this.relations, relation, this.cmp);
    }
    important() {
        if (this.relations.length > 0) {
            return this.relations[0].important;
        }
        else {
            return false;
        }
    }
    /**
     * If the returned number is less than 0, it indicates that the first item should come before the second item in the sorted order.
     * If the returned number is greater than 0, it indicates that the first item should come after the second item in the sorted order.
     * If the returned number is equal to 0, it means that the two items are considered equivalent in terms of sorting order.
     */
    ordering(other) {
        if (this.important() && !other.important()) {
            return 1;
        }
        if (!this.important() && other.important()) {
            return -1;
        }
        const la = this.relations.length;
        const lb = other.relations.length;
        for (let i = 0; i < Math.min(la, lb); i++) {
            if (!this.relations[i].important && !other.relations[i].important) {
                return 0;
            }
            if (!this.relations[i].important)
                return -1;
            if (!other.relations[i].important)
                return 1;
            // Both are important
            if (this.cmp) {
                const v = this.cmp(this.relations[i].value, other.relations[i].value);
                if (v !== 0)
                    return v;
            }
            else {
                if (this.relations[i].value < other.relations[i].value)
                    return -1;
                if (this.relations[i].value > other.relations[i].value)
                    return 1;
            }
        }
        return 0;
    }
}

const log$1 = debug("strategy");
class OrderedStrategy {
    members;
    manager;
    fetcher;
    // This can be T: controller or something
    notifier;
    // Contains a heap with all relations that have been launched
    // The heap will first handle unimportant relations,
    //   so when an important relation is handled, we can try to emit members
    //
    // With ordering ascending GT relations are important
    // With ordering descending LT relations are important
    launchedRelations;
    modulator;
    fetchNotifier;
    memberNotifer;
    fetchedPages;
    state;
    ordered;
    polling;
    toPoll;
    pollInterval;
    cancled = false;
    constructor(memberManager, fetcher, notifier, factory, ordered, polling, pollInterval) {
        const logger = log$1.extend("constructor");
        this.ordered = ordered;
        this.manager = memberManager;
        this.fetcher = fetcher;
        this.notifier = notifier;
        this.polling = polling;
        this.pollInterval = pollInterval;
        this.toPoll = new Heap((a, b) => a.chain.ordering(b.chain));
        this.launchedRelations = new Heap((a, b) => a.ordering(b));
        this.fetchedPages = new Heap((a, b) => a.relation.ordering(b.relation));
        this.state = [];
        // Callbacks for the fetcher
        // - seen: the strategy wanted to fetch an uri, but it was already seen
        //         so one fetch request is terminated, inFlight -= 1, and remove it from the launchedRelations
        // - pageFetched: a complete page is fetched and the relations have been extracted
        //         start member extraction
        // - relationFound: a relation has been found, put the extended chain in the queue
        this.fetchNotifier = {
            error: (error) => {
                this.notifier.error(error, {});
            },
            scheduleFetch: ({ target, expected }, { chain }) => {
                chain.target = target;
                this.toPoll.push({ chain, expected });
                this.notifier.mutable({}, {});
            },
            pageFetched: (page, { chain, index }) => {
                logger("Page fetched %s", page.url);
                this.modulator.finished(index);
                this.handleFetched(page, chain);
            },
            relationFound: ({ from, target }, { chain }) => {
                from.expected.push(target.node);
                logger("Relation found %s", target.node);
                const newChain = chain.push(target.node, this.extractRelation(target));
                if (newChain.ordering(chain) >= 0) {
                    this.fetch(newChain, [from.target]);
                }
                else {
                    console.error("Found relation backwards in time, this indicates wrong tree structure. Ignoring");
                }
            },
        };
        // Callbacks for member manager
        // - done: extracting is done, indicate this
        // - extract: a member is extracted, add it to our heap
        this.memberNotifer = {
            error: (error) => {
                this.notifier.error(error, {});
            },
            done: (_member, rel) => {
                logger("Member done %s", rel.target);
                const found = this.findOrDefault(rel);
                found.extracting -= 1;
                this.notifier.fragment({}, {});
                this.checkEmit();
            },
            extracted: (member) => {
                this.members.push(member);
            },
        };
        this.modulator = factory.create("fetcher", new Heap((a, b) => a.item.chain.ordering(b.item.chain)), {
            ready: ({ item: { chain, expected }, index }) => {
                this.fetcher.fetch({ target: chain.target, expected }, { chain, index }, this.fetchNotifier);
            },
        }, (inp) => {
            const { chain, expected } = inp;
            const cmp = this.ordered === "ascending"
                ? (a, b) => {
                    if (a > b)
                        return 1;
                    if (a < b)
                        return -1;
                    return 0;
                }
                : (a, b) => {
                    if (a > b)
                        return -1;
                    if (a < b)
                        return 1;
                    return 0;
                };
            return {
                chain: new RelationChain(chain.source, chain.target, chain.relations, undefined, cmp),
                expected,
            };
        });
        if (ordered == "ascending") {
            this.members = new Heap((a, b) => {
                if (a.id.equals(b.id))
                    return 0;
                if (a.timestamp == b.timestamp)
                    return 0;
                if (!a && b)
                    return 1;
                if (a && !b)
                    return -1;
                if (a.timestamp < b.timestamp)
                    return -1;
                return 1;
            });
        }
        else {
            this.members = new Heap((a, b) => {
                if (a.id.equals(b.id))
                    return 0;
                if (a.timestamp == b.timestamp)
                    return 0;
                if (!a && b)
                    return -1;
                if (a && !b)
                    return 1;
                if (a.timestamp < b.timestamp)
                    return 1;
                return -1;
            });
        }
    }
    start(url) {
        const logger = log$1.extend("start");
        logger("Starting at %s", url);
        const cmp = (a, b) => {
            if (a > b)
                return 1;
            if (a < b)
                return -1;
            return 0;
        };
        if (this.ordered === "ascending") {
            this.fetch(new RelationChain("", url, [], undefined, (a, b) => cmp(a, b)).push(url, {
                important: false,
                value: 0,
            }), []);
        }
        else {
            this.fetch(new RelationChain("", url, [], undefined, (a, b) => -1 * cmp(a, b)).push(url, { important: false, value: 0 }), []);
        }
    }
    cancel() {
        this.cancled = true;
    }
    findOrDefault(chain) {
        const out = this.state.find((x) => x.rel.ordering(chain) == 0);
        if (out) {
            return out;
        }
        const nel = { rel: chain, inFlight: 0, extracting: 0, closed: false };
        this.state.push(nel);
        return nel;
    }
    /**
     * Extracting basic information from the relation, according to the current configuration
     * Sorting in ascending order: if a relation comes in with a LT relation, then that relation important, because it can be handled later
     * Sorting in descending order: if a relation comes in with a GT relation, then that relation important, because it can be handled later
     */
    extractRelation(rel) {
        const val = (s) => {
            try {
                return new Date(s);
            }
            catch (ex) {
                return s;
            }
        };
        if (this.ordered === "ascending" && GTRs.some((x) => rel.type.equals(x))) {
            return {
                important: true,
                // Maybe this should create a date
                value: val(rel.value[0].value),
            };
        }
        else if (this.ordered === "descending" &&
            LTR.some((x) => rel.type.equals(x))) {
            return {
                important: true,
                // Maybe this should create a date
                value: val(rel.value[0].value),
            };
        }
        else {
            return {
                important: false,
                value: 0,
            };
        }
    }
    fetch(rel, expected) {
        this.launchedRelations.push(rel);
        this.findOrDefault(rel).inFlight += 1;
        this.modulator.push({ chain: rel, expected });
    }
    handleFetched(page, relation) {
        this.fetchedPages.push({ page, relation });
        // Update internal state
        // Page is fetched and will now be extracted
        const found = this.findOrDefault(relation);
        found.extracting += 1;
        found.inFlight -= 1;
        this.manager.extractMembers(page, relation, this.memberNotifer);
    }
    /**
     * Maybe we can emit a member
     * Only the case when our current relation is important
     */
    checkEmit() {
        let head = this.launchedRelations.pop();
        while (head) {
            const marker = head.relations[0] || { value: 0, important: false };
            const found = this.findOrDefault(head);
            // If this relation still has things in transit, or getting extracted, we must wait
            if (found.inFlight != 0 || found.extracting != 0) {
                break;
            }
            // Actually emit some members in order
            if (marker.important) {
                found.closed = true;
                let member = this.members.pop();
                while (member) {
                    // Euhm yeah, what to do if there is no timestamp?
                    if (!member.timestamp) {
                        this.notifier.member(member, {});
                    }
                    else if (this.ordered == "ascending"
                        ? member.timestamp < marker.value
                        : member.timestamp > marker.value) {
                        this.notifier.member(member, {});
                    }
                    else {
                        break;
                    }
                    member = this.members.pop();
                }
                // This member failed, let's put him back
                if (member) {
                    this.members.push(member);
                }
            }
            head = this.launchedRelations.pop();
        }
        if (head) {
            this.launchedRelations.push(head);
        }
        this.checkEnd();
    }
    checkEnd() {
        if (this.cancled)
            return;
        const logger = log$1.extend("checkEnd");
        // There are no relations more to be had, emit the other members
        if (this.launchedRelations.isEmpty()) {
            logger("No more launched relations");
            let member = this.members.pop();
            while (member) {
                this.notifier.member(member, {});
                member = this.members.pop();
            }
            if (this.polling) {
                logger("Polling is enabled, settings timeout");
                setTimeout(() => {
                    if (this.cancled)
                        return;
                    this.notifier.pollCycle({}, {});
                    const toPollArray = this.toPoll.toArray();
                    logger("Let's repoll (%o)", toPollArray.map((x) => x.chain.target));
                    this.toPoll.clear();
                    for (let rel of toPollArray) {
                        this.launchedRelations.push(rel.chain);
                        this.findOrDefault(rel.chain).inFlight += 1;
                        this.findOrDefault(rel.chain).closed = false;
                        this.modulator.push(rel);
                    }
                }, this.pollInterval || 1000);
            }
            else {
                logger("Closing the notifier, polling is not set");
                this.cancled = true;
                this.notifier.close({}, {});
            }
        }
    }
}

/**
 * Predicates representing greater than relations
 */
const GTRs = [
    types.TREE.terms.GreaterThanRelation,
    types.TREE.terms.GreaterThanOrEqualToRelation,
];
/**
 * Predicates representing less than relations
 */
const LTR = [
    types.TREE.terms.LessThanRelation,
    types.TREE.terms.LessThanOrEqualToRelation,
];

const log = debug("client");
const df = new rdfDataFactory.DataFactory();
function replicateLDES(config, ordered = "none", dereferencer, streamId) {
    return new Client(intoConfig(config), ordered, dereferencer, streamId);
}
async function getInfo(ldesId, store, dereferencer, config) {
    const logger = log.extend("getShape");
    if (config.shapeFile) {
        const shapeId = config.shapeFile.startsWith("http")
            ? config.shapeFile
            : "file://" + config.shapeFile;
        const resp = await dereferencer.dereference(config.shapeFile, {
            localFiles: true,
            fetch: config.fetch,
        });
        const quads = await streamToArray(resp.data);
        config.shape = {
            quads: quads,
            shapeId: df.namedNode(shapeId),
        };
    }
    let shapeIds = config.noShape
        ? []
        : getObjects(store, ldesId, types.TREE.terms.shape);
    let timestampPaths = getObjects(store, ldesId, types.LDES.terms.timestampPath);
    let isVersionOfPaths = getObjects(store, ldesId, types.LDES.terms.versionOfPath);
    logger("Found %d shapes, %d timestampPaths, %d isVersionOfPaths", shapeIds.length, timestampPaths.length, isVersionOfPaths.length);
    if (!config.noShape &&
        (shapeIds.length === 0 ||
            timestampPaths.length === 0 ||
            isVersionOfPaths.length === 0)) {
        try {
            logger("Maybe find more info at %s", ldesId.value);
            const resp = await dereferencer.dereference(ldesId.value, {
                localFiles: true,
                fetch: config.fetch,
            });
            store = rdfStores.RdfStore.createDefault();
            await new Promise((resolve, reject) => {
                store.import(resp.data).on("end", resolve).on("error", reject);
            });
            shapeIds = getObjects(store, null, types.TREE.terms.shape);
            timestampPaths = getObjects(store, null, types.LDES.terms.timestampPath);
            isVersionOfPaths = getObjects(store, null, types.LDES.terms.versionOfPath);
            logger("Found %d shapes, %d timestampPaths, %d isVersionOfPaths", shapeIds.length, timestampPaths.length, isVersionOfPaths.length);
        }
        catch (ex) { }
    }
    if (shapeIds.length > 1) {
        console.error("Expected at most one shape id, found " + shapeIds.length);
    }
    if (timestampPaths.length > 1) {
        console.error("Expected at most one timestamp path, found " + timestampPaths.length);
    }
    if (isVersionOfPaths.length > 1) {
        console.error("Expected at most one versionOf path, found " + isVersionOfPaths.length);
    }
    const shapeConfigStore = rdfStores.RdfStore.createDefault();
    if (config.shape) {
        for (const quad of config.shape.quads) {
            shapeConfigStore.addQuad(quad);
        }
        // Make sure the shapeId is as defined in the given shape file
        if (config.shape.shapeId.value.startsWith("file://")) {
            config.shape.shapeId = extractMainNodeShape(shapeConfigStore);
        }
    }
    return {
        extractor: new extractCbdShape.CBDShapeExtractor(config.shape ? shapeConfigStore : store, dereferencer, {
            cbdDefaultGraph: config.onlyDefaultGraph,
            fetch: config.fetch,
        }),
        shape: config.shape ? config.shape.shapeId : shapeIds[0],
        timestampPath: timestampPaths[0],
        isVersionOfPath: isVersionOfPaths[0],
    };
}
class Client {
    config;
    dereferencer;
    fetcher;
    memberManager;
    strategy;
    streamId;
    ordered;
    modulatorFactory;
    stateFactory;
    listeners = {};
    constructor(config, ordered = "none", dereferencer, stream) {
        this.config = config;
        this.dereferencer = dereferencer ?? rdfDereference.rdfDereferencer;
        this.streamId = stream;
        this.ordered = ordered;
        this.stateFactory = config.stateFile
            ? new FileStateFactory(config.stateFile)
            : new NoStateFactory();
        this.modulatorFactory = new ModulatorFactory(this.stateFactory);
        if (typeof process !== 'undefined') {
            process.on("SIGINT", () => {
                console.log("Caught interrupt signal, saving");
                this.stateFactory.write();
                process.exit();
            });
        }
    }
    on(key, fn) {
        this.listeners[key] = (this.listeners[key] || []).concat(fn);
    }
    emit(key, data) {
        (this.listeners[key] || []).forEach(function (fn) {
            fn(data);
        });
    }
    async init(emit, close, factory) {
        const logger = log.extend("init");
        // Fetch the url
        const root = await fetchPage(this.config.url, this.dereferencer, this.config.fetch);
        // Try to get a shape
        // TODO Choose a view
        const viewQuads = root.data.getQuads(null, types.TREE.terms.view, null, null);
        let ldesId = df.namedNode(this.config.url);
        if (!this.config.urlIsView) {
            if (viewQuads.length === 0) {
                console.error("Did not find tree:view predicate, this is required to interpret the LDES");
            }
            else {
                ldesId = viewQuads[0].object;
            }
        }
        const info = await getInfo(ldesId, root.data, this.dereferencer, this.config);
        const state = this.stateFactory.build("members", (set) => {
            const arr = [...set.values()];
            return JSON.stringify(arr);
        }, (inp) => new Set(JSON.parse(inp)), () => new Set());
        this.streamId = this.streamId || viewQuads[0].subject;
        this.memberManager = new Manager(this.streamId || viewQuads[0].subject, state.item, info);
        logger("timestampPath %o", !!info.timestampPath);
        if (this.ordered !== "none" && !info.timestampPath) {
            throw "Can only emit members in order, if LDES is configured with timestampPath";
        }
        this.fetcher = new Fetcher(this.dereferencer, this.config.loose, this.config.condition, this.config.fetch);
        const notifier = {
            error: (ex) => this.emit("error", ex),
            fragment: () => this.emit("fragment", undefined),
            member: (m) => {
                if (this.config.condition.matchMember(m)) {
                    emit(m);
                }
            },
            pollCycle: () => {
                this.emit("poll", undefined);
            },
            mutable: () => {
                this.emit("mutable", undefined);
            },
            close: () => {
                this.stateFactory.write();
                close();
            },
        };
        this.strategy =
            this.ordered !== "none"
                ? new OrderedStrategy(this.memberManager, this.fetcher, notifier, factory, this.ordered, this.config.polling, this.config.pollInterval)
                : new UnorderedStrategy(this.memberManager, this.fetcher, notifier, factory, this.config.polling, this.config.pollInterval);
        logger("Found %d views, choosing %s", viewQuads.length, ldesId.value);
        this.strategy.start(ldesId.value);
    }
    stream(strategy) {
        const emitted = longPromise();
        const config = {
            //
            // Called when starting the stream
            //
            start: async (controller) => {
                this.on("error", (error) => {
                    this.stateFactory.write();
                    this.memberManager.close();
                    this.fetcher.close();
                    controller.error(error);
                });
                this.modulatorFactory.pause();
                await this.init((member) => {
                    controller.enqueue(member);
                    resetPromise(emitted);
                }, () => controller.close(), this.modulatorFactory);
            },
            //
            // Called when the internal buffer is not full
            //
            pull: async () => {
                resetPromise(emitted);
                this.modulatorFactory.unpause();
                await emitted.waiting;
                this.modulatorFactory.pause();
                return;
            },
            //
            // Called when canceled
            //
            cancel: async () => {
                log("Canceled");
                this.stateFactory.write();
                this.strategy.cancel();
                this.memberManager.close();
                this.fetcher.close();
            },
        };
        const out = new ReadableStream(config, strategy);
        return out;
    }
}
async function fetchPage(location, dereferencer, fetch_f) {
    const resp = await dereferencer.dereference(location, {
        localFiles: true,
        fetch: fetch_f,
    });
    const url = resp.url;
    const data = rdfStores.RdfStore.createDefault();
    await new Promise((resolve, reject) => {
        data.import(resp.data).on("end", resolve).on("error", reject);
    });
    return { url, data };
}
async function processor(writer, url, before, after, ordered, follow, pollInterval, shape, noShape, save, loose, urlIsView, verbose, fetch_config) {
    if (fetch_config?.auth) {
        fetch_config.auth.host = new URL(url).host;
    }
    const client = replicateLDES({
        loose,
        noShape,
        shapeFile: shape,
        polling: follow,
        url: url,
        stateFile: save,
        pollInterval: pollInterval,
        urlIsView,
        fetch: fetch_config ? enhanced_fetch(fetch_config) : fetch,
        // condition: todo
    }, ordered || "none");
    if (verbose) {
        client.on("fragment", () => console.error("Fragment!"));
    }
    return async () => {
        const reader = client.stream({ highWaterMark: 10 }).getReader();
        let el = await reader.read();
        const seen = new Set();
        while (el) {
            if (el.value) {
                seen.add(el.value.id);
                if (verbose) {
                    if (seen.size % 100 == 1) {
                        console.error("Got member", seen.size, "with", el.value.quads.length, "quads");
                    }
                }
                const blank = df.blankNode();
                const quads = el.value.quads.slice();
                quads.push(df.quad(blank, types.SDS.terms.stream, client.streamId), df.quad(blank, types.SDS.terms.payload, el.value.id));
                await writer.push(new n3.Writer().quadsToString(quads));
            }
            if (el.done) {
                break;
            }
            el = await reader.read();
        }
        if (verbose) {
            console.error("Found", seen.size, "members");
        }
    };
}

exports.Client = Client;
exports.Range = Range;
exports.empty_condition = empty_condition;
exports.extractMainNodeShape = extractMainNodeShape;
exports.intoConfig = intoConfig;
exports.parse_condition = parse_condition;
exports.processor = processor;
exports.replicateLDES = replicateLDES;
exports.retry_fetch = retry_fetch;
