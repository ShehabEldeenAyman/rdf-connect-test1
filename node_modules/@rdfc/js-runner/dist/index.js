import { Store } from "n3";
import { getArgs } from "./args.js";
import { load_store, LOG } from "./util.js";
export * from "./connectors.js";
import path from "path";
import { RDF } from "@treecg/types";
import { ChannelFactory, Conn, JsOntology } from "./connectors.js";
import { extractShapes } from "rdf-lens";
function safeJoin(a, b) {
    if (b.startsWith("/")) {
        return b;
    }
    return path.join(a, b);
}
export async function extractProcessors(source, apply) {
    const store = new Store();
    await load_store(source, store);
    const quads = store.getQuads(null, null, null, null);
    const config = extractShapes(quads, apply);
    const subjects = quads
        .filter((x) => x.predicate.equals(RDF.terms.type) &&
        x.object.equals(JsOntology.JsProcess))
        .map((x) => x.subject);
    const processorLens = config.lenses[JsOntology.JsProcess.value];
    const processors = subjects.map((id) => processorLens.execute({ id, quads }));
    return { processors, quads, shapes: config };
}
export function extractSteps(proc, quads, config) {
    const out = [];
    const subjects = quads
        .filter((x) => x.predicate.equals(RDF.terms.type) && x.object.equals(proc.ty))
        .map((x) => x.subject);
    const processorLens = config.lenses[proc.ty.value];
    const fields = proc.mapping.parameters;
    for (let id of subjects) {
        const obj = processorLens.execute({ id, quads });
        const functionArgs = new Array(fields.length);
        for (let field of fields) {
            functionArgs[field.position] = obj[field.parameter];
        }
        out.push(functionArgs);
    }
    return out;
}
export async function jsRunner() {
    const args = getArgs();
    const cwd = process.cwd();
    const source = {
        location: safeJoin(cwd, args.input).replaceAll("\\", "/"),
        type: "remote",
    };
    const factory = new ChannelFactory();
    const apply = {};
    apply[Conn.ReaderChannel.value] = factory.createReader.bind(factory);
    apply[Conn.WriterChannel.value] = factory.createWriter.bind(factory);
    const { processors, quads, shapes: config, } = await extractProcessors(source, apply);
    LOG.main("Found %d processors", processors.length);
    const starts = [];
    for (let proc of processors) {
        const argss = extractSteps(proc, quads, config);
        const jsProgram = await import("file://" + proc.file);
        process.chdir(proc.location);
        for (let args of argss) {
            starts.push(await jsProgram[proc.func](...args));
        }
    }
    await factory.init();
    for (let s of starts) {
        if (s && typeof s === "function") {
            s();
        }
    }
}
