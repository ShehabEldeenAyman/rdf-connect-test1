import { Quad, Term } from "@rdfjs/types";
import { BasicLens, BasicLensM, Cont } from "./lens.js";
export interface ShapeField {
    name: string;
    path: BasicLensM<Cont, Cont>;
    minCount?: number;
    maxCount?: number;
    extract: BasicLens<Cont, any>;
}
export interface Shape {
    id: string;
    ty: Term;
    description?: string;
    fields: ShapeField[];
}
export declare function toLens(shape: Shape): BasicLens<Cont, {
    [label: string]: any;
}>;
export declare const RdfList: BasicLens<Cont, Term[]>;
export declare const ShaclSequencePath: BasicLens<Cont, BasicLensM<Cont, Cont>>;
export declare const ShaclAlternativepath: BasicLens<Cont, BasicLensM<Cont, Cont>>;
export declare const ShaclPredicatePath: BasicLens<Cont, BasicLensM<Cont, Cont>>;
export declare const ShaclInversePath: BasicLens<Cont, BasicLensM<Cont, Cont>>;
export declare function MultiPath(predicate: Term, min: number, max?: number): BasicLens<Cont, BasicLensM<Cont, Cont>>;
export declare const ShaclPath: BasicLens<Cont, BasicLensM<Cont, Cont>>;
type Cache = {
    [clazz: string]: BasicLens<Cont, any>;
};
type SubClasses = {
    [clazz: string]: string;
};
export declare const CBDLens: BasicLensM<Cont, Quad>;
export declare const Cached: (lens: BasicLens<Cont, any>, cachedLenses: {
    lenses: {
        lens: BasicLens<Cont, any>;
        from: BasicLens<Cont, any>;
    }[];
}) => BasicLens<Cont, any>;
export declare const TypedExtract: (cache: Cache, apply: ApplyDict, subClasses: SubClasses) => BasicLens<Cont, any>;
export type ApplyDict = {
    [label: string]: (item: any) => any;
};
export declare function extractShape(cache: Cache, subclasses: {
    [label: string]: string;
}, apply: ApplyDict): BasicLens<Cont, Shape[]>;
export type Shapes = {
    shapes: Shape[];
    lenses: Cache;
    subClasses: SubClasses;
};
export declare function extractShapes(quads: Quad[], apply?: ApplyDict, customClasses?: Cache): Shapes;
export {};
//# sourceMappingURL=shacl.d.ts.map