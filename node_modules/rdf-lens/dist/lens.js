let lensIndex = 0;
export class BasicLens {
    _exec;
    index;
    constructor(execute) {
        this._exec = execute;
        this.index = lensIndex;
        lensIndex += 1;
    }
    asMulti() {
        return (new BasicLensM((c, _, states) => {
            const out = this.execute(c, states);
            return out;
        }));
    }
    and(...and) {
        return (new BasicLens((c, _, states) => {
            const a = this.execute(c, states);
            const rest = and.map((x) => x.execute(c, states));
            return [a, ...rest];
        }));
    }
    orM(...others) {
        return new BasicLensM((c, _, states) => {
            const all = [this, ...others];
            return all.flatMap((x) => {
                try {
                    return [x.execute(c, states)];
                }
                catch (ex) {
                    return [];
                }
            });
        });
    }
    or(...others) {
        return new BasicLens((c, _, states) => {
            try {
                return this.execute(c, states);
            }
            catch (ex) {
                for (let i = 0; i < others.length; i++) {
                    try {
                        return others[i].execute(c, states);
                    }
                    catch (ex) { }
                }
            }
            throw "nope";
        });
    }
    map(fn) {
        return new BasicLens((c, _, states) => {
            const a = this.execute(c, states);
            return fn(a);
        });
    }
    then(next) {
        return new BasicLens((c, _, states) => {
            const a = this.execute(c, states);
            return next.execute(a, states);
        });
    }
    execute(container, states = []) {
        if (!states[this.index]) {
            states[this.index] = {};
        }
        return this._exec(container, states[this.index], states);
    }
}
export class BasicLensM extends BasicLens {
    one(def) {
        return new BasicLens((c, _, states) => {
            const qs = this.execute(c, states);
            return qs[0] || def;
        });
    }
    expectOne() {
        return new BasicLens((c, _, states) => {
            const qs = this.execute(c, states);
            if (qs.length < 1)
                throw "Nope";
            return qs[0];
        });
    }
    thenAll(next) {
        return new BasicLensM((c, _, states) => {
            const qs = this.execute(c, states);
            return qs.flatMap((x) => {
                try {
                    const o = next.execute(x, states);
                    return [o];
                }
                catch (ex) {
                    return [];
                }
            });
        });
    }
    thenSome(next) {
        return this.thenAll(next);
    }
    thenFlat(next) {
        return new BasicLensM((c, _, states) => {
            const qs = this.execute(c, states);
            return qs.flatMap((x) => next.execute(x, states));
        });
    }
    mapAll(fn) {
        return new BasicLensM((c, _, states) => {
            const qs = this.execute(c, states);
            return qs.map(fn);
        });
    }
    orAll(...others) {
        return new BasicLensM((c, _, states) => {
            let out = [];
            try {
                out.push(...this.execute(c, states));
            }
            catch (ex) { }
            for (let i = 0; i < others.length; i++) {
                try {
                    out.push(...others[i].execute(c, states));
                }
                catch (ex) { }
            }
            return out;
        });
    }
    filter(fn) {
        return new BasicLensM((c, _, states) => {
            return this.execute(c, states).filter(fn);
        });
    }
}
export function pred(pred) {
    return new BasicLensM(({ quads, id }) => {
        const out = quads.filter((q) => q.subject.equals(id) && (!pred || q.predicate.equals(pred)));
        return out.map((q) => ({ quads, id: q.object }));
    });
}
export function invPred(pred) {
    return new BasicLensM(({ quads, id }) => {
        const out = quads.filter((q) => q.object.equals(id) && (!pred || q.predicate.equals(pred)));
        return out.map((q) => ({ quads, id: q.subject }));
    });
}
export function predTriple(pred) {
    return new BasicLensM(({ quads, id }) => {
        const out = quads.filter((q) => q.subject.equals(id) && (!pred || q.predicate.equals(pred)));
        return out.map((q) => ({ quads, id: q }));
    });
}
export function unique() {
    return new BasicLensM((qs) => {
        const literals = {};
        const named = {};
        const blank = {};
        for (let q of qs) {
            const ty = q.id.termType;
            if (ty === "Literal")
                literals[q.id.value] = q;
            if (ty === "NamedNode")
                named[q.id.value] = q;
            if (ty === "BlankNode")
                blank[q.id.value] = q;
        }
        const out = [];
        out.push(...Object.values(literals));
        out.push(...Object.values(named));
        out.push(...Object.values(blank));
        return out;
    });
}
export function subjects() {
    return new BasicLensM((quads) => {
        return quads.map((x) => ({ id: x.subject, quads }));
    });
}
export function match(subject, predicate, object) {
    return new BasicLensM((quads) => {
        return quads
            .filter((x) => (!subject || x.subject.equals(subject)) &&
            (!predicate || x.predicate.equals(predicate)) &&
            (!object || x.object.equals(object)))
            .map((id) => ({ id, quads }));
    });
}
export const subject = new BasicLens(({ id, quads }) => ({
    id: id.subject,
    quads,
}));
export const predicate = new BasicLens(({ id, quads }) => ({
    id: id.predicate,
    quads,
}));
export const object = new BasicLens(({ id, quads }) => ({
    id: id.object,
    quads,
}));
export function empty() {
    return new BasicLens((x) => x);
}
