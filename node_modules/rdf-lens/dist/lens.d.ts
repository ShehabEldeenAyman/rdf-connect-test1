import type { Quad, Term } from "@rdfjs/types";
export type Cont<Q = Term> = {
    id: Q;
    quads: Quad[];
};
export type Res<T> = [Term, T];
export declare class BasicLens<C, T> {
    _exec: (container: C, state: any, states: any[]) => T;
    index: number;
    constructor(execute: (container: C, state: any, states: any[]) => T);
    asMulti(): T extends any[] ? BasicLensM<C, T[number]> : never;
    and<F extends any[]>(...and: {
        [K in keyof F]: BasicLens<C, F[K]>;
    }): BasicLens<C, [T, ...{
        [K in keyof F]: F[K];
    }]>;
    orM(...others: BasicLens<C, T>[]): BasicLensM<C, T>;
    or(...others: BasicLens<C, T>[]): BasicLens<C, T>;
    map<F>(fn: (t: T) => F): BasicLens<C, F>;
    then<F>(next: BasicLens<T, F>): BasicLens<C, F>;
    execute(container: C, states?: any[]): T;
}
export declare class BasicLensM<C, T> extends BasicLens<C, T[]> {
    one<D = T>(def?: D): BasicLens<C, T | D>;
    expectOne(): BasicLens<C, T>;
    thenAll<F>(next: BasicLens<T, F>): BasicLensM<C, F>;
    thenSome<F>(next: BasicLens<T, F>): BasicLensM<C, F>;
    thenFlat<F>(next: BasicLensM<T, F>): BasicLensM<C, F>;
    mapAll<F>(fn: (t: T) => F): BasicLensM<C, F>;
    orAll(...others: BasicLensM<C, T>[]): BasicLensM<C, T>;
    filter(fn: (object: T) => boolean): BasicLensM<C, T>;
}
export declare function pred(pred?: Term): BasicLensM<Cont, Cont>;
export declare function invPred(pred?: Term): BasicLensM<Cont, Cont>;
export declare function predTriple(pred?: Term): BasicLensM<Cont, Cont<Quad>>;
export declare function unique(): BasicLensM<Cont[], Cont>;
export declare function subjects(): BasicLensM<Quad[], Cont>;
export declare function match(subject: Term | undefined, predicate: Term | undefined, object: Term | undefined): BasicLensM<Quad[], Cont<Quad>>;
export declare const subject: BasicLens<Cont<Quad>, Cont>;
export declare const predicate: BasicLens<Cont<Quad>, Cont>;
export declare const object: BasicLens<Cont<Quad>, Cont>;
export declare function empty<C>(): BasicLens<C, C>;
//# sourceMappingURL=lens.d.ts.map