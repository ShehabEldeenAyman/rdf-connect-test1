"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShapesGraph = void 0;
var Path_1 = require("./Path");
var types_1 = require("@treecg/types");
var Shape_1 = require("./Shape");
var rdf_data_factory_1 = require("rdf-data-factory");
var df = new rdf_data_factory_1.DataFactory();
var SHACL = (0, types_1.createTermNamespace)("http://www.w3.org/ns/shacl#", "zeroOrMorePath", "zeroOrOnePath", "oneOrMorePath", "inversePath", "alternativePath", "deactivated", "minCount", "path", "node", "closed", "property", "and", "xone", "or", "NodeShape");
var ShapesGraph = /** @class */ (function () {
    function ShapesGraph(shapeStore) {
        this.shapes = this.initializeFromStore(shapeStore);
        this.counter = 0;
    }
    /**
     * This function returns a Mermaid representation of a shape identified by a given term.
     * @param term {Term} - The term of the Shape that is the start of the representation.
     */
    ShapesGraph.prototype.toMermaid = function (term) {
        var startShape = this.shapes.get(term);
        this.counter = 0;
        if (!startShape) {
            throw new Error("No shape found for term \"".concat(term.value, "\""));
        }
        var mermaid = 'flowchart LR\n';
        mermaid += this.toMermaidSingleShape(startShape, '1', startShape.label || 'Shape');
        return mermaid;
    };
    /**
     * This function returns a Mermaid representation of a given shape.
     * @param shape - The shape for which to generate a representation.
     * @param id - The ID to identify the shape in the representation.
     * @param name - The name used for the shape in the representation.
     * @private
     */
    ShapesGraph.prototype.toMermaidSingleShape = function (shape, id, name) {
        var _this = this;
        var mermaid = "  S".concat(id, "((").concat(name, "))\n");
        var alreadyProcessedPaths = [];
        shape.nodeLinks.forEach(function (nodeLink) {
            var p = nodeLink.pathPattern.toString();
            var isPathRequired = _this.isPathRequired(p, shape.requiredPaths);
            alreadyProcessedPaths.push(p);
            p = _this.cleanPath(p);
            var linkedShape = _this.shapes.get(nodeLink.link);
            if (!linkedShape) {
                throw new Error("The linked shape \"".concat(nodeLink.link, "\" is not found"));
            }
            var linkedShapeId = "".concat(id, "_").concat(_this.counter);
            var link = '-->';
            if (!isPathRequired) {
                link = '-.->';
            }
            if (p.startsWith('^')) {
                p = p.substring(1);
                mermaid += "  S".concat(linkedShapeId, "[ ]").concat(link, "|\"").concat(p, "\"|S").concat(id, "\n");
            }
            else {
                mermaid += "  S".concat(id).concat(link, "|\"").concat(p, "\"|S").concat(linkedShapeId, "[ ]\n");
            }
            _this.counter++;
            var linkedShapeMermaid = _this.toMermaidSingleShape(linkedShape, linkedShapeId, linkedShape.label || 'Shape');
            mermaid += linkedShapeMermaid;
        });
        shape.atLeastOneLists.forEach(function (list) {
            if (list.length > 0) {
                var xId_1 = "".concat(id, "_").concat(_this.counter);
                mermaid += "  S".concat(id, "---X").concat(xId_1, "{OR}\n");
                list.forEach(function (shape) {
                    var shapeId = "".concat(id, "_").concat(_this.counter);
                    _this.counter++;
                    mermaid += "  X".concat(xId_1, "---S").concat(shapeId, "\n");
                    var linkedShapeMermaid = _this.toMermaidSingleShape(shape, shapeId, shape.label || 'Shape');
                    mermaid += linkedShapeMermaid;
                });
            }
        });
        mermaid += this.simplePathToMermaid(shape.requiredPaths, alreadyProcessedPaths, id, '-->');
        mermaid += this.simplePathToMermaid(shape.optionalPaths, alreadyProcessedPaths, id, '-.->');
        return mermaid;
    };
    /**
     * This function removes < and > from a path.
     * @param path - The path from which to remove the < and >.
     * @private
     */
    ShapesGraph.prototype.cleanPath = function (path) {
        path = path.replace(/</g, '');
        return path.replace(/>/g, '');
    };
    /**
     * This function returns true if the given path is required.
     * @param path - The path that needs to be checked.
     * @param requiredPaths - An array of all required paths.
     * @private
     */
    ShapesGraph.prototype.isPathRequired = function (path, requiredPaths) {
        var e_1, _a;
        try {
            for (var requiredPaths_1 = __values(requiredPaths), requiredPaths_1_1 = requiredPaths_1.next(); !requiredPaths_1_1.done; requiredPaths_1_1 = requiredPaths_1.next()) {
                var requiredPath = requiredPaths_1_1.value;
                if (path === requiredPath.toString()) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (requiredPaths_1_1 && !requiredPaths_1_1.done && (_a = requiredPaths_1.return)) _a.call(requiredPaths_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    /**
     * This function returns a Mermaid presentation for an array of simple paths.
     * This function is intended to be used with shape.requiredPaths and shape.optionalPaths.
     * @param paths - An array of paths.
     * @param alreadyProcessedPaths - An array of stringified paths that already have been processed.
     * @param shapedId - The id of the shape to which these paths belong.
     * @param link - The Mermaid link that needs to be used.
     * @private
     */
    ShapesGraph.prototype.simplePathToMermaid = function (paths, alreadyProcessedPaths, shapedId, link) {
        var _this = this;
        var mermaid = '';
        paths.forEach(function (path) {
            var p = path.toString();
            if (alreadyProcessedPaths.includes(p)) {
                return;
            }
            alreadyProcessedPaths.push(p);
            p = _this.cleanPath(p);
            if (_this.isRealInversePath(p)) {
                p = _this.getRealPath(p);
                mermaid += "  S".concat(shapedId, "_").concat(_this.counter, "[ ]").concat(link, "|\"").concat(p, "\"|S").concat(shapedId, "\n");
            }
            else {
                p = _this.getRealPath(p);
                mermaid += "  S".concat(shapedId).concat(link, "|\"").concat(p, "\"|S").concat(shapedId, "_").concat(_this.counter, "[ ]\n");
            }
            _this.counter++;
        });
        return mermaid;
    };
    /**
     * This function returns true if a given path is real inverse path.
     * This means that the path is not a double, quadruple, ... inverse path.
     * @param path - The path that needs to be checked.
     * @private
     */
    ShapesGraph.prototype.isRealInversePath = function (path) {
        var found = path.match(/^(\^+)[^\^]+/);
        if (!found) {
            return false;
        }
        return found[1].length % 2 !== 0;
    };
    /**
     * This function removes all the ^ from the path.
     * @param path - The path from which to remove the ^.
     * @private
     */
    ShapesGraph.prototype.getRealPath = function (path) {
        var found = path.match(/^\^*([^\^]+)/);
        if (!found) {
            throw new Error("No real path found in \"".concat(path, "\""));
        }
        return found[1];
    };
    ShapesGraph.prototype.constructPathPattern = function (shapeStore, listItem) {
        var _this = this;
        if (listItem.termType === "BlankNode") {
            //Look for special types
            var zeroOrMorePathObjects = getObjects(shapeStore, listItem, SHACL.zeroOrMorePath, null);
            var oneOrMorePathObjects = getObjects(shapeStore, listItem, SHACL.oneOrMorePath, null);
            var zeroOrOnePathObjects = getObjects(shapeStore, listItem, SHACL.zeroOrOnePath, null);
            var inversePathObjects = getObjects(shapeStore, listItem, SHACL.inversePath, null);
            var alternativePathObjects = getObjects(shapeStore, listItem, SHACL.alternativePath, null);
            if (zeroOrMorePathObjects[0]) {
                return new Path_1.ZeroOrMorePath(this.constructPathPattern(shapeStore, zeroOrMorePathObjects[0]));
            }
            else if (oneOrMorePathObjects[0]) {
                return new Path_1.OneOrMorePath(this.constructPathPattern(shapeStore, oneOrMorePathObjects[0]));
            }
            else if (zeroOrOnePathObjects[0]) {
                return new Path_1.ZeroOrOnePath(this.constructPathPattern(shapeStore, zeroOrOnePathObjects[0]));
            }
            else if (inversePathObjects[0]) {
                return new Path_1.InversePath(this.constructPathPattern(shapeStore, inversePathObjects[0]));
            }
            else if (alternativePathObjects[0]) {
                var alternativeListArray = this.rdfListToArray(shapeStore, alternativePathObjects[0]).map(function (value) {
                    return _this.constructPathPattern(shapeStore, value);
                });
                return new Path_1.AlternativePath(alternativeListArray);
            }
            else {
                var items = this.rdfListToArray(shapeStore, listItem);
                return new Path_1.SequencePath(items.map(function (x) { return _this.constructPathPattern(shapeStore, x); }));
            }
        }
        return new Path_1.PredicatePath(listItem);
    };
    /**
     * @param shapeStore
     * @param propertyShapeId
     * @param shape
     * @param required
     * @returns false if it wasn't a property shape
     */
    ShapesGraph.prototype.preprocessPropertyShape = function (shapeStore, propertyShapeId, shape, required) {
        //Skip if shape has been deactivated
        var deactivated = getObjects(shapeStore, propertyShapeId, SHACL.deactivated, null);
        if (deactivated.length > 0 && deactivated[0].value === "true") {
            return true; //Success: doesn't matter what kind of thing it was, it's deactivated so let's just proceed
        }
        var path = getObjects(shapeStore, propertyShapeId, SHACL.path, null)[0];
        //Process the path now and make sure there's a match function
        if (!path) {
            return false; //this isn't a property shape...
        }
        var pathPattern = this.constructPathPattern(shapeStore, path);
        var minCount = getObjects(shapeStore, propertyShapeId, SHACL.minCount, null);
        if ((minCount[0] && minCount[0].value !== "0") || required) {
            shape.requiredPaths.push(pathPattern);
        }
        else {
            //TODO: don't include node links?
            shape.optionalPaths.push(pathPattern);
        }
        // **TODO**: will the sh:or, sh:xone, sh:and, etc. be of use here? It won't contain any more information about possible properties?
        // Maybe to potentially point to another node, xone a datatype?
        // Does it link to a literal or to a new node?
        var nodeLink = getObjects(shapeStore, propertyShapeId, SHACL.node, null);
        if (nodeLink[0]) {
            shape.nodeLinks.push(new Shape_1.NodeLink(pathPattern, nodeLink[0]));
        }
        //TODO: Can Nodelinks appear in conditionals from here? Probably they can? (same comment as â†‘)
        return true; // Success: the property shape has been processed
    };
    /**
     * Processes a NodeShape or PropertyShape and adds NodeLinks and required properties to the arrays.
     * @param shapeStore
     * @param shapeId
     * @param shape
     * @returns
     */
    ShapesGraph.prototype.preprocessShape = function (shapeStore, shapeId, shape) {
        return this.preprocessPropertyShape(shapeStore, shapeId, shape)
            ? true
            : this.preprocessNodeShape(shapeStore, shapeId, shape);
    };
    /**
     * Processes a NodeShape
     * @param shapeStore
     * @param nodeShapeId
     * @param shape
     */
    ShapesGraph.prototype.preprocessNodeShape = function (shapeStore, nodeShapeId, shape) {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d;
        var _this = this;
        // Extract label
        var rdfsLabel = getObjects(shapeStore, nodeShapeId, types_1.RDFS.terms.label)[0];
        if (rdfsLabel) {
            shape.label = rdfsLabel.value;
        }
        else {
            shape.label = nodeShapeId.termType === "BlankNode" ?
                nodeShapeId.value :
                nodeShapeId.value.split("/")[nodeShapeId.value.split("/").length - 1];
        }
        //Check if it's closed or open
        var closedIndicator = getObjects(shapeStore, nodeShapeId, SHACL.closed, null)[0];
        if (closedIndicator && closedIndicator.value === "true") {
            shape.closed = true;
        }
        //Process properties if it has any
        var properties = getObjects(shapeStore, nodeShapeId, SHACL.property, null);
        try {
            for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                var prop = properties_1_1.value;
                this.preprocessPropertyShape(shapeStore, prop, shape);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return)) _a.call(properties_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            // process sh:and: just add all IDs to this array
            // Process everything you can find nested in AND clauses
            for (var _e = __values(getObjects(shapeStore, nodeShapeId, SHACL.and, null)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var andList = _f.value;
                try {
                    // Try to process it as a property shape
                    //for every andList found, iterate through it and try to preprocess the property shape
                    for (var _g = (e_4 = void 0, __values(this.rdfListToArray(shapeStore, andList))), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var and = _h.value;
                        this.preprocessShape(shapeStore, and, shape);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_c = _g.return)) _c.call(_g);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            //Process zero or more sh:xone and sh:or lists in the same way -- explanation in README why they can be handled in the same way
            for (var _j = __values(getObjects(shapeStore, nodeShapeId, SHACL.xone, null).concat(getObjects(shapeStore, nodeShapeId, SHACL.or, null))), _k = _j.next(); !_k.done; _k = _j.next()) {
                var xoneOrOrList = _k.value;
                var atLeastOneList = this.rdfListToArray(shapeStore, xoneOrOrList).map(function (val) {
                    var newShape = new Shape_1.ShapeTemplate();
                    //Create a new shape and process as usual -- but mind that we don't trigger a circular shape here...
                    _this.preprocessShape(shapeStore, val, newShape);
                    return newShape;
                    //Add this one to the shapesgraph
                });
                shape.atLeastOneLists.push(atLeastOneList);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_d = _j.return)) _d.call(_j);
            }
            finally { if (e_5) throw e_5.error; }
        }
        //And finally, we're just ignoring sh:not. Don't process this one
    };
    /**
     * @param shapeStore
     */
    ShapesGraph.prototype.initializeFromStore = function (shapeStore) {
        var e_6, _a;
        //get all named nodes of entities that are sh:NodeShapes which we'll recognize through their use of sh:property (we'll find other relevant shape nodes later on)
        //TODO: This is a limitation though: we only support NodeShapes with at least one sh:property set? Other NodeShapes in this context are otherwise just meaningless?
        var shapeNodes = []
            .concat(getSubjects(shapeStore, SHACL.property, null, null))
            .concat(getSubjects(shapeStore, types_1.RDF.terms.type, SHACL.NodeShape, null))
            .concat(getObjects(shapeStore, null, SHACL.node, null))
            //DISTINCT
            .filter(function (value, index, array) {
            return array.findIndex(function (x) { return x.equals(value); }) === index;
        });
        var shapes = new Shape_1.RDFMap();
        try {
            for (var shapeNodes_1 = __values(shapeNodes), shapeNodes_1_1 = shapeNodes_1.next(); !shapeNodes_1_1.done; shapeNodes_1_1 = shapeNodes_1.next()) {
                var shapeId = shapeNodes_1_1.value;
                var shape = new Shape_1.ShapeTemplate();
                //Don't process if shape is deactivated
                var deactivated = getObjects(shapeStore, shapeId, SHACL.deactivated, null);
                if (!(deactivated.length > 0 && deactivated[0].value === "true")) {
                    this.preprocessNodeShape(shapeStore, shapeId, shape);
                    shapes.set(shapeId, shape);
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (shapeNodes_1_1 && !shapeNodes_1_1.done && (_a = shapeNodes_1.return)) _a.call(shapeNodes_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return shapes;
    };
    /**
     * Processes all element from an RDF List, or detects it wasn't a list after all and it's just one element.
     * @param shapeStore
     * @param item
     * @returns
     */
    ShapesGraph.prototype.rdfListToGenerator = function (shapeStore, item) {
        var rest;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!getObjects(shapeStore, item, df.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), null)[0]) return [3 /*break*/, 5];
                    return [4 /*yield*/, getObjects(shapeStore, item, df.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), null)[0]];
                case 1:
                    _a.sent();
                    rest = getObjects(shapeStore, item, df.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), null)[0];
                    _a.label = 2;
                case 2:
                    if (!(rest &&
                        rest.value !== "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil")) return [3 /*break*/, 4];
                    return [4 /*yield*/, getObjects(shapeStore, rest, df.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), null)[0]];
                case 3:
                    _a.sent();
                    rest = getObjects(shapeStore, rest, df.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), null)[0];
                    return [3 /*break*/, 2];
                case 4: return [3 /*break*/, 7];
                case 5: 
                // It's not a list. It's just one element.
                return [4 /*yield*/, item];
                case 6:
                    // It's not a list. It's just one element.
                    _a.sent();
                    _a.label = 7;
                case 7: return [2 /*return*/];
            }
        });
    };
    ShapesGraph.prototype.rdfListToArray = function (shapeStore, item) {
        return Array.from(this.rdfListToGenerator(shapeStore, item));
    };
    return ShapesGraph;
}());
exports.ShapesGraph = ShapesGraph;
var getSubjects = function (store, predicate, object, graph) {
    return store.getQuads(null, predicate, object, graph).map(function (quad) {
        return quad.subject;
    });
};
var getObjects = function (store, subject, predicate, graph) {
    return store.getQuads(subject, predicate, null, graph).map(function (quad) {
        return quad.object;
    });
};
//# sourceMappingURL=ShapesGraph.js.map